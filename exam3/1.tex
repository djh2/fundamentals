% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{alltt}
\usepackage{ct} % tight CM font for \tt
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\ifrubric
\centerline{\Large CSU2510H Exam 1 Rubric -- Spring 2012}

\else
\centerline{\Large CSU2510H Exam 1 -- Spring 2012}

\vspace{0.5cm}

\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}

\noindent\begin{minipage}{8cm}\sloppy
\begin{itemize}
\item You may use the usual primitives and expression forms of any of
  the \code{class} languages; for everything else, define it.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} for
  {\tt (check-expect {\slshape c e})} and $\lambda$ for
  \code{lambda} to save time writing.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item We expect data \emph{and} interface definitions.

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can be thinking
about the harder problems in background while you knock off the easy ones.
\end{itemize}

\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & ?\\ \hline
2 & & ?\\ \hline
3 & & ?\\ \hline
4 & & ?\\ \hline
5 & & ?\\ \hline
Extra & & ? \\ \hline
{\bf Total} & & 83 \\ \hline
%{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \noindent
% {\bf Home on the Range}

% Come up with funny story here.



% \newpage
\begin{problem}\pts{17} % same as on the previous exam :)

Here is a data definition for a class of objects.  It intentionally
uses meaningless names to test whether you've sufficiently
internalized the data-driven development process we've talked about
since the Fall.

\begin{verbatim}
;; A P is one of:          
;; - A                  ;; An A is a (new a% String)
;; - B                  ;; A  B is a (new b% String A)
;; - C                  ;; A  C is a (new c% P)

(define-class a% (fields cookoo))
(define-class b% (fields gaga bang))
(define-class c% (fields doodle))
\end{verbatim}

\noindent
Design the following methods for \verb|P|s:

\begin{enumerate}

\item \verb|size| - the size of an \verb|A| is $5$; the size of a
  \verb|B| is $8$, regardless of what's inside; and the size of a
  \verb|C| contributes $1$ to the size of the \verb|P| inside.

\item \verb|replace-gaga| - produces a \verb|P| with the \verb|gaga|
  field of any \verb|B| within this \verb|P| with a given string.

\item \verb|same-gaga-cookoo?| - produces true for any \verb|P| which
  contains a \verb|B| whose \verb|gaga| is equal to a given string and
  whose \verb|bang| is an \verb|A| whose \verb|cookoo| is equal to
  another given string.  Produces false otherwise.

\end{enumerate}

Be sure to define any interfaces you need so that your program and say
which classes implement which interfaces so that your program treats
all values according to their interface.

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}

;; A P implements:
;; - size : -> Number
;;   Size of this P.
;; - replace-gaga : String -> P
;;   Replace gaga field (if any) of this P with given string.
;; - same-gaga-cookoo? : String String -> Boolean
;;   Is there a B within this P with given gaga field and cookoo field?

;; An A implements:
;; - cookoo : -> String
;;   Get the cookoo string.

;; In a%:
(define (size) 5)
(define (replace-gaga str) this)
(define (same-gaga-cookoo? g c) false)

;; In b%:
(define (size) 8)
(define (replace-gaga str)
  (new b% str (this . bang)))
(define (same-gaga-cookoo? g c)
  (and (string=? g (this . gaga))
       (string=? c (this . bang . cookoo))))

;; In c%:
(define (size) (add1 (this . doodle . size)))
(define (replace-gaga str)
  (new c% (this . doodle . replace-gaga str)))
(define (same-gaga-cookoo? g c)
  (this . doodle . same-gaga-cookoo? g c))

\end{verbatim}
\end{solution}
\end{problem}
%\ifrubric\bigskip\else
\newpage
%\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{18}

Here are data, class, and interface definitions for a list of numbers:
\begin{alltt}
;; An LoN is one of:
;; - (new mt%)
;; - (new cons% Number LoN)
;; and implements:
;; - sum : -> Number
;;   Compute the sum of the numbers in this list.
;; - sqrs : -> LoN
;;   List of squares of each number in this list.

(define-class mt%
  (define (sum) 0)
  (define (sqrs) this))

(define-class cons%
  (fields first rest)
  (define (sum)
    (+ (this . first)
       (this . rest . sum)))
  (define (sqrs)
    (new cons% 
         (sqr (this . first)) ; (sqr x) = x\(\sp{2}\)
         (this . rest . sqrs))))
\end{alltt}
%
Here are some examples:
\begin{verbatim}
(check-expect ((new mt%) . sum) 0)
(check-expect ((new cons% 4 (new cons% 5 (new mt%))) . sum)  9)
(check-expect ((new mt%) . sqrs) (new mt%))
(check-expect ((new cons% 4 (new cons% 5 (new mt%))) . sqrs)
              (new cons% 16 (new cons% 25 (new mt%))))
\end{verbatim}

\newpage
\noindent
Develop the \verb|sum-sqrs| method that computes the sum of the
squares of a list of numbers.  Here is an example:
\begin{verbatim}
(check-expect ((new cons% 4 (new cons% 5 (new mt%))) . sum-sqrs) 
              (+ 16 25))
\end{verbatim}

If you can, define a super class of \verb|mt%| and \verb|cons%| and
lift the definition of \verb|sum-sqrs| to this class.  (We will assume
the appropriate \verb|super| declaration in \verb|mt%| and
\verb|cons%|.)  If you cannot, define methods in both \verb|mt%| and
\verb|cons%| for partial credit.

\begin{solution}
\begin{verbatim}
(define-class list%
  (define (sum-sqrs)
    ((this . sqrs) . sum)))

(check-expect ((new mt%) . sum-sqrs) 0)
\end{verbatim}
\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{12}

One perspective that unifies the paradigms of programming with
functions and programming with objects is to view a ``function'' as an
object that understands a method called \code{apply}.  With that in
mind, we can define an interface for functions-as-objects:

\begin{verbatim}
;; A [IFun X Y] implements:
;; apply : X -> Y
;; Apply this function to the given input.
\end{verbatim}

Here we are representing a \code{X -> Y} function as an object that
has an \code{apply} method that consumes an \code{X} and produces a
\code{Y}.

\begin{enumerate}
\item Design a class that wraps a real function with contract \code{(X
  -> Y)} to implement \code{[IFun X Y]}.

\item Using your wrapper class, construct the objects representing the
  ``add 1'' function and ``sub 1'' function.

\item Another useful operation on functions is composition.  Here is
  the interface for a \code{compose} method that composes two functions
  represented as objects:

\begin{verbatim}
;; [IFun X Y] also implements:
;; compose : [IFun Y Z] -> [IFun X Z]
;; Produce a function that applies this function to its input, 
;; then applies the given function to that result.
\end{verbatim}

For example, if \code{addone} and \code{subone} refer to the objects
you constructed in part 2, the following check should succeed:

\begin{verbatim}
(check-expect ((addone . compose subone) . apply 5) 5)
(check-expect ((addone . compose addone) . apply 5) 7)
\end{verbatim}

Implement the \code{compose} method for your wrapper class.
\end{enumerate}

\begin{solution}

\begin{verbatim}
;; Part 1 [5pt]
(define-class fun%
  (fields f)
  (define/public (apply x)
    ((field f) x)))

;; Part 2 [2pt]
(define addone (fun% add1))
(define subone (fun% sub1))

;; Part 3 [5pt]
(define-class fun%
  (fields f)
  (define/public (compose g)
    (fun% (lambda (x)
            (g . apply (apply x))))))
\end{verbatim}

\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{21}

The Northeastern University Registrar is instituting a new course
registration system, in which each student will wait in a ``Virtual
Line'' until every student ahead of them has registered.  A simple way
to represent a line (also known as a \emph{queue}) is by using a list.
But this representation makes it slow to add somebody to the end of
the line (or to take somebody off the front of the line, depending on
whether the front of the list represents the front or rear of the
line).  

In order to provide maximal waiting efficiency, you have been tasked
with implementing a representation that uses \emph{two} lists!  The
key idea of this fancy representation is that one list will represent
some portion of the front of the line, while the other will represent
the remainder of the line \emph{in reverse order}.  So if you're the
first element of the first list, you are at the head of the line.  On
the other hand, if you're the first element of the second list, you
are the very last person in line.
%
Here is the interface for queues:
\begin{verbatim}
;; A [IQ X] implements:
;;
;; head : -> X
;; Produce the element at the head of this queue.
;; Assume: this queue is not empty.
;;
;; deq : -> [IQ X]      (Short for "dequeue")
;; Produces a new queue like this queue, but without 
;; this queue's first element.
;; Assume: this queue is not empty.
;;
;; enq : X -> [IQ X]    (Short for "enqueue")
;; Produce new queue with given element added to the
;; END of this queue.
;;
;; emp? : -> Boolean
;; Is this queue empty?
\end{verbatim}

The \code{head} and \code{deq} operations require that the queue be
non-empty when they are used, but this can be assumed and these
operations do not need to check for an empty queue.

Further, the Registrar's office has just learned about
\emph{invariants}, and insists on maintaining the following invariant
about all of their queues:

\begin{quote}
  {\it if the front of the queue is empty, the whole queue must also be empty.}
\end{quote} 

\noindent
The Registrar's office has given you three tasks to prepare their
Virtual Line for its launch later this semester:

\begin{enumerate}
\item Design an implementation of the queue data structure to the Registrar's
  specifications.  You must maintain the invariant stated above, and
  you should take advantage of the invariant when implementing the
  operations.
\item Unfortunately, when testing the queue, the Registrar has
  discovered that some queues with the same elements in the same order
  can be represented in multiple ways.  Give an example of two
  different representations of the same queue.  Implement a
  \code{to-list} operation which produces a list of elements going in
  order from the front to the rear of the queue. In your tests, you
  should show how this addresses the problem.
\item The Registrar has a problem with careless data entry.  Design
  and implement a constructor for queues which, given two input lists
  of elements, ensures that the invariant is maintained.  
\end{enumerate}

\begin{solution}
\begin{verbatim}
;; Part 1:
;; invariant: front is empty IFF queue is empty
;; A [Queue X] is (queue% [Listof X] [Listof X])           [1pt]
;; and implements [IQ X]

(define-class queue%                                       [1pt]
  (fields front back)
  ;; Add element to the back
  ;; X -> [Queue X]
  ;; add it to the front IFF the front is empty
  ;; (otherwise invariant is violated)
  (check-expect (eq . enqueue 1) (queue% '(1) '()))        [1pt]
  (check-expect (q . enqueue 5) (queue% '(1 2 3) '(5)))
  (define/public (enqueue i)
    (cond [(empty? (field front))                          [2pt]
           (queue% (list i) empty)]
          [else
           (queue% (field front) (cons i (field back)))])) [2pt]
  ;; get the first element
  ;;  -> X
  ;; assumes this queue is non-empty
  ;; uses the invariant
  (check-expect (q . head) 1)                              [1pt]
  (define/public (head)                                    
    (first (field front)))
  ;; drop the first element
  ;;  -> [Queue X]
  ;; assumes this queue is non-empty
  (check-expect (eq . enqueue 1 . dequeue) eq)             [1pt]
  (check-expect (q . enqueue 5 . dequeue) (queue% '(2 3) '(5)))
  (define/public (dequeue)
    (cond 
      ;; maintain the invariant -- don't let `front' be empty
      [(empty? (rest (field front)))                       [3pt]
       (queue% (reverse (field back)) empty)]
      ;; otherwise, simple
      [else (queue% (rest (field front)) (field back))]))  [2pt]
  ;; is this queue empty?
  ;; emp? : -> Boolean
  ;; uses the invariant
  (check-expect (q . emp?) false)                          [1pt]
  (check-expect (eq . emp?) true)
  (define/public (emp?)
    (empty? (field front)))

;; Part 2:

;; Examples:                                               [1pt]
(queue% (list 1) (list 6)) vs (queue% (list 1 6) empty)
(queue% (list 1 8 12) (list 6)) vs (queue% (list 1 8) (list 12 6))

  ;; convert the queue to a list                           [1pt]
  ;; -> [Listof X] 
  ;; turn examples above into tests:                       [1pt]
  (check-expect ((queue% (list 1) (list 6)) . to-list)
		((queue% (list 1 6) empty) . to-list))
  (check-expect ((queue% (list 1 8 12) (list 6)) . to-list)
		((queue% (list 1 8) (list 12 6)) . to-list))
  (check-expect (q . to-list) '(1 2 3))                    
  (check-expect (q . enqueue 5 . to-list) '(1 2 3 5))   
  (check-expect (q . enqueue 5 . dequeue . to-list) '(2 3 5))
  (define/public (to-list)                                 [1pt]
    (append (field front)
            (reverse (field back)))))

(define q (queue% '(1 2 3) empty))
(define eq (queue% empty empty))

;; Part 3:                                                 [2pt]
;; several good possibilities (others are possible)
(constructor (f b)
  (fields (append f (reverse b)) empty))

(constructor (f b)
  (cond [(empty? f) (fields (reverse b) empty)]
	[else (fields f b)]))

(constructor (f b)
  (cond [(and (empty? f) (empty? b)) (fields f b)]
	[(empty? f) (fields (reverse b) empty)]
	[else (fields f b)]))

\end{verbatim}
\end{solution}
\end{problem}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{15}
Last night, Asumu was up late improving the {\tt class} languages.
Unfortunately, he was too tired to test his work, and his last commit
broke the numeric system.
%
This puts us in the dire position of no longer being able to calculate
the factorial of large numbers, and we turn to you for help.

This is the definition of a class of functional objects
with a {\tt fact} method:

\begin{verbatim}
;; A Fact is (new fact%) and implements 
;; - fact : Natural -> Natural
;;   Compute n!.
(define-class fact%
  (define (fact n)
    (cond [(zero? n) 1]
          [else (* n (this . fact (sub1 n)))])))
\end{verbatim}

Since we can no longer rely on built in numbers to represent
\verb|Natural|s, we will represent \verb|Natural|s with objects and
then rewrite the \verb|fact| method to operate over this new kind of
data.

Here is the \verb|Natural| interface:

\begin{verbatim}
;; A Natural implements:
;; - zero? : -> Boolean
;;   is this Natural the zero value?
;; - sub1 : -> Natural
;;   produce a natural one less than this natural 
;;   (or zero if this natural is zero)
;; - times : Natural -> Natural
;;   multiply this natural by the given natural
\end{verbatim}

\newpage
Write a new definition of the \verb|fact| method using \verb|Natural|,
and \emph{not} using the built-in numbers of the class system or
DrRacket.  You can assume there is a defined constant \verb|one|,
which is a \verb|Natural| object representing $1$.

\ifrubric
\else
\fi

\newpage

Now, design a data defintion that implements \verb|Natural|, and
supports the methods \verb|zero?|, \verb|sub1|, and \verb|times|.
Define the constant \verb|one|.  (\emph{Hint}: remember that the
natural numbers can be seen as a recursive union; a natural number is
either zero, or one more than a natural number.)

It will be helpful to define the helper methods \verb|add1| and
\verb|plus|.  Also, remember that $n + m = (n-1) + m + 1$ and that $n
\cdot m = (n-1) \cdot m + n$.  Don't overlook the slightly weird
specification for \verb|sub1|: $0-1 = 0$; this weirdness is common
amongst mathematicians when working with natural numbers.

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi
\end{problem}

\begin{solution}
\begin{verbatim}


;; Part 1: N Points
(define-class fact%
  (define (fact n)
    (cond [(n . zero?) one]
          [else (n . times (this . fact (n . sub1)))])))


;; Part 2: M points
;; A Natural is one of
;; - (new zero%)
;; - (new succ% Natural)
(define-class zero%
  (define (sub1) this)
  (define (plus n) n)
  (define (add1) (new succ% this))
  (define (times n) this)
  (define (zero?) true))

(define-class succ%
  (fields pred)
  (define (zero?) false)
  (define (add1) (new succ% this))
  (define (plus n) (this . pred . plus n . add1))
  (define (times n) (this . pred . times n . plus n))
  (define (sub1) (this . pred)))

(define one (new succ% (new zero%)))
(define zero (new zero%))

(check-expect (one . zero?) false)
(check-expect (one . sub1) zero)
(check-expect ((new succ% one) . sub1) one)
(check-expect (zero . zero?) true)
(check-expect (zero . sub1) zero)
\end{verbatim}
\newpage
\end{solution}

\begin{problem}

\textbf{Extra Credit}
\\
\noindent
After Van Horn discovered the problems with numbers, he attempted to
fix them.  Unfortunately, not only did he not fix them, he broke
booleans as well.  Fortunately, we have an idea about how you can
help, expressed in the following data definitions.  

\begin{verbatim}
;; A Bool implements:
;; - branch : [Action X] [Action X] -> X
;;   run the first action if this bool is true, 
;;   otherwise run the second action

;; An [Action X] implements:
;; - run : -> X
;; run this action


\end{verbatim}

Following these interface definitions, design data and class
defintions for implementations of the \verb|Bool| interface, and
reimplement the \verb|fact| method to use them.
You may modify your natural number implementation if neccessary for
your solution.

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\fi


\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\fi
\end{problem}

\begin{solution}
\begin{verbatim}
(define-class fact%
  (define (fact n)
    (n . zero? . branch (new const% one) (new recur% n))))
(define-class const%
  (fields run))
(define-class recur%
  (fields n)
  (define (run) ((new fact%) . fact (this . n . sub1) . times n)))

(define-class t%
  (define (branch t e) (t . run)))
(define-class f%
  (define (branch t e) (e . run)))

(define true (new t%))
(define false (new f%))
\end{verbatim}
\end{solution}
\end{document}


