% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{alltt}
\usepackage{ct} % tight CM font for \tt
\usepackage[usenames,dvipsnames]{xcolor}
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{\color{Red}}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\centerline{\Large CSU2510H Exam 2 \ifrubric (SOLUTION) \fi-- Spring 2013}

\vspace{0.5cm}

\ifrubric\relax\else
\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}
\fi

\noindent\begin{minipage}{8cm}\sloppy
\begin{itemize}

\item All problems must be done in Java. You may use any Java we have
  used in class and in lab; anything else must be defined.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} as
  shorthand for writing {\tt
    Tester.checkExpect}; the {\tt Examples} class and {\tt test}
  method around the tests are not required.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item We expect data \emph{and} interface definitions.

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

% \item The extra credit problem is \emph{all or nothing};  no partial
%   credit will be awarded.

\item Unless specifically requested, templates and super classes are
  \emph{not} required.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can  think
about the harder problems in the background while you knock off the easy ones.
\end{itemize}
\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & 20\\ \hline
2 & & 25\\ \hline
3 & & 18\\ \hline
Extra & & 5 \\ \hline
{\bf Total} & & 63+5 \\ \hline
%{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

\begin{center}
{\bf Java Reference}
\end{center}
\noindent
You may be asked to use or implement the following standard Java
interfaces, which are described here for reference:

\begin{enumerate}
\item \texttt{Iterable<X>} -- Implementing this interface allows an object to be the target of the ``foreach'' statement. 

 Methods:
 \begin{itemize}
 \item \texttt{Iterator<X> iterator()} : Returns an iterator over a set of
  elements of type \texttt{X}.
  \end{itemize}

\item \texttt{Iterator<X>} -- An iterator over a collection.

  Methods:
  \begin{itemize}
    \item \texttt{boolean hasNext()} : Returns \texttt{true} if the iteration
      has more elements.
    \item \texttt{X next()} : Returns the next element in the iteration.
  \end{itemize}

\item \texttt{Comparator<X>} -- A comparison function, which imposes a total ordering on some collection of objects.

  Methods:
  \begin{itemize}
    \item \texttt{int compare(X o1, X o2)} : Compares its two
      arguments for order. Returns a negative integer, zero, or a
      positive integer as the first argument is less than, equal to,
      or greater than the second.
  \end{itemize}
  
\end{enumerate}

\newpage

\begin{problem} \pts{20}

A \emph{binary search tree} (BST) is a lot like a binary tree in that
a BST is either a node, which contains an element and a left and right
subtree, or a leaf, which contains neither elements nor subtrees.  The
difference between a binary tree and a binary \emph{search} tree is
that every leaf and node of a BST also contains a \texttt{Comparator},
and nodes have the following invariant: every element in the left
subtree is smaller (according to the comparator) than the element in
the node, which in turn is smaller than or equal to (according to the
comparator) every element in the right subtree.  (You can assume
the comparator in every leaf and node is the same for any given BST.)

\begin{enumerate}
\item Design class and interface definitions for binary search trees
  \texttt{BST<X>}.  Design the following method for binary search
  trees:
  \begin{verbatim}
  // Insert x into this BST, preserving the BST invariant
  BST<X> insert(X x);
\end{verbatim}

\ifrubric

\begin{solution}
\begin{verbatim}
// [1pt]
interface BST<X> extends Iterable<X> {
    // Insert given element into this BST.
    BST<X> insert(X x);
}

// [optional]
abstract class ABST<X> implements BST<X> {
    Comparator<X> c;
    ABST(Comparator<X> c) {
        this.c = c;
    }
}

// [1pt: fields, constructor, parameterized type]
class Leaf<X> extends ABST<X> {
    Leaf(Comparator<X> c) {
        super(c);
    }

    // [1pt]
    public BST<X> insert(X x) {
        return new Node<X>(this.c, x, this, this);
    }
}

// [2pt: fields, constructor, parameterized type]
class Node<X> extends ABST<X> {
    X x;
    BST<X> left;
    BST<X> right;
    Node(Comparator<X> c, X x, BST<X> left, BST<X> right) {
        super(c);
        this.x = x;
        this.left = left;
        this.right = right;
    }

    // [3pt]
    public BST<X> insert(X x) {
        return (this.c.compare(x, this.x) < 0)
        ? new Node<X>(this.c, this.x, this.left.insert(x), this.right)
        : new Node<X>(this.c, this.x, this.left, this.right.insert(x));
        }
    }
}

// [2pt: tests]
\end{verbatim}
\end{solution}

\else
\newpage
[Here is some more space for the previous problem.]
\fi

\newpage
\item Here's an idea for sorting a series of elements: take all of the
 elements and insert them into (an initially empty) binary search
 tree.  Now, assuming \texttt{BST<X>} implemented the
 \texttt{Iterable<X>} interface such that the iterator produced by
 \texttt{iterator()} visited the elements of the BST in increasing
 order (according to the comparator), then the elements could be retrieved
in sorted order.

Use this idea to implement a sorting method with the signature given
 below.  It should sort the elements of a given iterable object in ascending order
 according to a given comparator, producing the sorted elements as an
 array list.

You may assume \texttt{BST<X>} implements \texttt{Iterable<X>} correctly
and do not need to define this yourself (see the extra credit problem).

{\small
\begin{verbatim}
// Class of sorting methods
class Sort {
  // Produce an array list of elems sorted in ascending order by c
  <X> ArrayList<X> treeSort(Comparator<X> c, Iterable<X> elems) { 
    ... 
  }
}
\end{verbatim}}
\end{enumerate}

\ifrubric
\begin{solution}
\begin{verbatim}
// [5pt]
class Sort {
    <X> ArrayList<X> treeSort(Comparator<X> c, Iterable<X> elems) {
        BST<X> bst = new Leaf<X>(c);
        ArrayList<X> ls = new ArrayList<X>();
        for (X x : elems) bst = bst.insert(x);
        for (X x : bst)   ls.add(x);
        return ls;
    }
}

// [2pt]
class LessThan implements Comparator<Integer> {
    public int compare(Integer x, Integer y) {
        return x - y;
    }
}

// [3pt]
class Examples {
    void testTreeSort(Tester t) {
        Sort s = new Sort();
        Comparator<Integer> lt = new LessThan();
        ArrayList<Integer> elems =
            new ArrayList<Integer>(Arrays.asList(8,3,7,5));
        
        ArrayList<Integer> sorted =
            new ArrayList<Integer>(Arrays.asList(3,5,7,8));

        t.checkExpect(s.treeSort(lt, new ArrayList<Integer>()),
                      new ArrayList<Integer>());
        t.checkExpect(s.treeSort(lt, elems), sorted);
    }
}
\end{verbatim}
\end{solution}
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage
\newpage
\end{problem}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem} \pts{25}
\noindent
Tobin-Hochstadt has been asked to serve on a review panel for the
 National Science Foundation, which requires he read and make notes on
 a set of grant proposals the government is considering to fund.
  Rather than read the proposals he's been assigned, he's decided to
 make a program for modeling his notes.  His notes take the form of an
 outline, which consists of a peice of text and a list of (sub)notes.
  For example, here's one of his notes (thankfully not in his
 handwritting):
\begin{verbatim}
       NSF Proposal 1218390
       |
       +- Overview
       |  |
       |  +- WAT?
       |  |
       |  +- Motivations
       |     |
       |     +- unmotivating
       |
       +- Middle (fell asleep)
       |
       +- Conclusions
       |
       +- Budget
          |
          +- very large
          |
          +- underfund lots of BU undergrads
\end{verbatim}


%\bigskip
%\vskip{2}
\newpage

\begin{enumerate}

\item Develop data, class, and interface defintions for a note.

\newpage

\noindent
\item Develop the visitor pattern for notes by designing
  an \texttt{accept} method on notes that
  consumes a note visitor and uses it to compute something of a note.
  You will need to define the note visitor interface and may need to
  define additional visitors as well, depending on your original data
  definition.

\newpage

\noindent
\item Design a note visitor that produces the maximum nesting depth of
  a note.  For example, the maximum nesting depth of the given example
  is 4.


%  numbered outline of a
%   note.  The result should be an \texttt{ArrayList} of
%   \texttt{String}s.  For example, the numbered outline of the note
%   note is an \texttt{ArrayList<String>} with the following elements:

% \begin{verbatim}
% "1. NSF Proposal 1218390"
% "1.1. Overview"
% "1.1.1. WAT?"
% "1.1.2. Motivations"
% "1.1.2.1. unmotivating"
% "1.2. Middle (fell asleep)"
% "1.3. Conclusions"
% "1.4. Budget"
% "1.4.1. very large"
% "1.4.2. underfund lots of BU undergrads"
% \end{verbatim}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

\noindent
\item Here is a defintion for the \texttt{equals} and \texttt{hashCode}
methods for a note:

\begin{verbatim}
Boolean sameNote(Note s) { ... }

boolean equals(Object o) {
    return (o instanceof Note) 
        && this.sameNote((Note)o);
}

int hashCode() { return 42; }
\end{verbatim}

\noindent
Develop the \texttt{sameNote} method, which \texttt{equals} relies on.
(Two notes are the same if they have the same text and subnotes.)

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

\noindent
\item The definition for \texttt{hashCode} that we have presented is
  very simple, but it will reduce the performance of hash tables of
  notes.  Develop a better version of the \texttt{hashCode} method.
  Make sure that it can distinguish (at least \emph{some}) notes with
  the same text but different subnotes, as well as (some)
  notes with different text but the same subnotes.

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage
\newpage
\end{enumerate}
\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem} \pts{18}

In most general terms, you can think of a \emph{computation} as something that
\emph{runs} to compute an answer.  To solidify this idea as an interface, a
computation could be represented by an object implementing:

\begin{verbatim}
interface Computation<R> {
  // Run this computation
  R run();
}
\end{verbatim}

\noindent
For example, this computation computes the square of five:

\begin{verbatim}
class TwentyFive implements Computation<Integer> {
  Integer run() { return 5 * 5; }
}
\end{verbatim}

\begin{enumerate}

\item Design a computation that when constructed is given a
 \texttt{Computation<Integer>} and a natural number \emph{n}, and when
 run, runs the computation \emph{n} times and produces an array list
of all the results.

\newpage
\item

Computations can be expensive, so it's probably a good idea to avoid
 running them if you can, or if you must run them, run them just once
 and remember the result. Subsequent runs of the computation should
 then just return the remembered value rather than doing any real
 work.

In contemplating the design of a library for such laziness, you should
 realize that this idea of running something at most once and
 remembering its result is itself a computation.  In other words, if
 given a computation, you can make a new computation that will act
 just like the given one, except it will run the given computation at
 most one time.

Design the following class:

\begin{verbatim}
class MaybeOnce<R> implements Computation<R> {
  MaybeOnce(Computation<R> compute) { ... }

  // If this computation has never been run, run
  // compute and produce its result.  Remember
  // this answer for future runs and just return
  // it rather than re-run compute.
  R run() { ... }
}
\end{verbatim}

Take care to make sure that if a \texttt{MaybeOnce} computation is not
run, it never runs the inner computation.  For example, 
this program should not blow up (assuming this is the whole program):

\begin{verbatim}
class BlowUp implements Computation<Integer> {
  // Blows up when run
  Integer run() { throw new RuntimeException("KABOOM!"); }
}

// Never run, so never blows up.
new MaybeOnce<Integer>(new BlowUp())
\end{verbatim}
\end{enumerate}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage
\newpage

\end{problem}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

\begin{problem}  \pts{5}

{\bf Extra Credit}

\noindent
Revise your design of \texttt{BST<X>} to implement
 \texttt{Iterable<X>} interface.  The iterator returned by
 \texttt{iterator()} should iterate through the elements in sorted order.
 It should do this efficiently by relying on the \texttt{BST} invariant.

\begin{solution}
\begin{verbatim}
//> 5pts all correct
//> Ok if they have another implementation if it's right

// in BST<X> interface
    // Add all elements of this BST to ls, in order.
    void addTo(ArrayList<X> ls);

// in ABST<X>
    public Iterator<X> iterator() {
        ArrayList<X> elems = new ArrayList<X>();
        this.addTo(elems);
        return elems.iterator();
    }

// in Leaf<X>
    public void addTo(ArrayList<X> ls) {}

// in Node<X>
    public void addTo(ArrayList<X> ls) {
        this.left.addTo(ls);
        ls.add(this.x);
        this.right.addTo(ls);
    }
\end{verbatim}
\end{solution}

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}


