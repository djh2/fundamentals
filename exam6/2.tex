% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{alltt}
\usepackage{ct} % tight CM font for \tt
\usepackage[usenames,dvipsnames]{xcolor}
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{\color{Red}}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\centerline{\Large CSU2510H Exam 2 \ifrubric (SOLUTION) \fi-- Spring 2013}

\vspace{0.5cm}

\ifrubric\relax\else
\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}
\fi

\noindent\begin{minipage}{8cm}\sloppy
\begin{itemize}

\item All problems must be done in Java. You may use any Java we have
  used in class and in lab; anything else must be defined.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} as
  shorthand for writing {\tt
    Tester.checkExpect}; the {\tt Examples} class and {\tt test}
  method around the tests are not required.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item We expect data \emph{and} interface definitions.

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

% \item The extra credit problem is \emph{all or nothing};  no partial
%   credit will be awarded.

\item Unless specifically requested, templates and super classes are
  \emph{not} required.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can  think
about the harder problems in the background while you knock off the easy ones.
\end{itemize}
\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & 20\\ \hline
2 & & 19\\ \hline
Extra & & 5 \\ \hline
{\bf Total} & & 39+5 \\ \hline
%{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

\begin{problem} \pts{20}

A \emph{binary search tree} is a lot like a binary tree in that a BST
is either a node, which contains an element and a left and right
subtree, or a leaf, which doesn't contain an element or subtrees.  The
difference between a binary tree and a binary \emph{search} tree is
that every leaf and node of a BST also contains a \texttt{Comparator},
and nodes have the following invariant: every element in the left
subtree is smaller (according to the comparator) than the element in
the node, which in turn is smaller than or equal (according to the
comparator) to every element in the right subtree.  (You can assume
the comparator in every leaf and node is the same for any given BST.)

\begin{enumerate}
\item Design class and interface definitions for binary search trees
  \texttt{BST<X>}.  Design the following method for binary search
  trees:
  \begin{verbatim}
  // Insert x into this BST, preserving the BST invariant
  BST<X> insert(X x);
\end{verbatim}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\fi

\newpage
\item Here's an idea for sorting a series of elements: take all of the
 elements and insert them into (an initially empty) binary search
 tree.  Now, assuming \texttt{BST<X>} implemented the
 \texttt{Iterable<X>} such that the iterator produced by
 \texttt{iterator()} visited the elements of the BST in increasing
 order (according to the comparator), then the elements could be retrieved
in sorted order.

Use this idea to implement a sorting method with the signature given
 below.  It should sort a given iterable object in ascending order
 according to a given comparator, producing the sorted list as an
 array list of elements.

You may assume \texttt{BST<X>} implements \texttt{Iterable<X>} correctly
and do not need to define this yourself (see the extra credit).

{\small
\begin{verbatim}
// Class of sorting methods
class Sort {
  // Produce an array list of elems sorted in ascending order by c
  <X> ArrayList<X> treeSort(Comparator<X> c, Iterable<X> elems) { 
    ... 
  }
}
\end{verbatim}}
\end{enumerate}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage
\newpage
\end{problem}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem} \pts{20}
\noindent
Tobin-Hochstadt has been asked to serve on a review panel for the
National Science Foundation, which requires he read and make notes on
a set of grant proposals the government is considering to fund.
Rather than read the proposals, he's decided to make a program for
modeling his notes.  His notes take the form of an outline, which
consists of a peice of text and a list of (sub)notes.  For example,
here's one of his notes (thankfully not in his handwritting):
\begin{verbatim}
       NSF Proposal 1218390
       |
       +- Overview
       |  |
       |  +- WAT?
       |  |
       |  +- Motivations
       |     |
       |     +- unmotivating
       |
       +- Middle (fell asleep)
       |
       +- Conclusions
       |
       +- Budget
          |
          +- very large
          |
          +- lots of BU undergrads
\end{verbatim}


%\bigskip
%\vskip{2}
\newpage

\begin{enumerate}

\item Develop data, class, and interface defintions for a note.

\newpage

\noindent
\item Develop the visitor pattern for notes by designing
  an \texttt{accept} method on notes that
  consumes a note visitor and uses it to compute something of a note.
  You will need to define the note visitor interface and may need to
  define additional visitors as well, depending on your original data
  definition.

\newpage

\noindent
\item Write a note visitor that produces the numbered outline of a
  note.  The result should be an \texttt{ArrayList} of
  \texttt{String}s.  For example, the numbered outline of the note
  note is an \texttt{ArrayList<String>} with the following elements:

\begin{verbatim}
"1. NSF Proposal 1218390"
"1.1. Overview"
"1.1.1. WAT?"
"1.1.2. Motivations"
"1.1.2.1. unmotivating"
"1.2. Middle (fell asleep)"
"1.3. Conclusions"
"1.4. Budget"
"1.4.1. very large"
"1.4.2. lots of BU undergrads"
\end{verbatim}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

\noindent
\item Here is a defintion for the \texttt{equals} and \texttt{hashCode}
methods for a note:

\begin{verbatim}
Boolean sameNote(Note s) { ...}

boolean equals(Object o) {
    return (o instanceof Note) 
        && this.sameNote((Note)o);
}

int hashCode() { return 42; }
\end{verbatim}

\noindent
Develop the \texttt{sameNote} method, which \texttt{equals} relies on.
(Two notes are the same if they have the same text and subnotes.)

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage

\noindent
\item The definition for \texttt{hashCode} that we have presented is
  very simple, but it will reduce the performance of hash tables of
  notes.  Develop a better version of the \texttt{hashCode} method.
  Make sure that it can distinguish (at least \emph{some}) notes with
  the same text but different subnotes, as well as (some)
  notes with different text but the same subnotes.

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage
\newpage
\end{enumerate}
\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem} \pts{20}

Computation/thunk problem

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage
\newpage

\end{problem}

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}


