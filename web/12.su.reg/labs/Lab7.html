<html>  <head>    <title>CS 2510 Spring 2012: Lab 7 - Mutating Object State; Implementing Equality</title>  </head>    <h1>CS 2510 Spring 2012: Lab 7 - Mutating Object State; Implementing Equality</h1><h3>copyright 2012 Felleisen, Proulx, et. al.</h3>    <body><h4>Goals</h4><p>Today we <em>touch the void</em> (we want to scare you here... just see the movie, or read the book, to understand how scary the<tt>void</tt> can be).<p>To understand <em>mutation</em> we need to learn how to:</p><ul><li>Design methods that modify the state of an object</li><li>Design tests for effectful methods</li><li>Design methods that define equality</li></ul><hr></hr><h3>&nbsp;&nbsp;The Problem.</h3><p>For this Lab we will work with bank accounts again.  For our purposeswe have <em>savings accounts</em>, which must maintain a positivebalance, <em>checking accounts</em>, which require a minimum balance(not zero), and <em>credit lines</em>, which records the balancecurrently owed and the maximum the customer can borrow. The bank has alist of <tt>Account</tt>s where a customer may deposit or withdrawmoney. A withdraw from an account cannot reduce the balance below theminimum, and, for credit lines, cause the balance owed to be above themaximum limit. When a customer deposits money to an account, thebalance increases, though for a credit line this decreases the amountowed, which cannot drop below zero.</p><h3  class=section>1&nbsp;&nbsp;Methods that effect a simple state change.</h3><ol><li><p> Start a new project named <tt>Lab7-Bank</tt> and import into  it the files from  <a href="Lab7.zip">Lab7.zip</a>. </p></li><li><p>Make examples of <tt>Checking</tt>, <tt>Savings</tt>, and  <tt>Credit</tt> accounts.</p>  <p>We've started you off with two of them using  a different organization than you are used to.  We use a  <tt>reset()</tt> method to initialize the examples, rather than  initializing them in place.  Follow the same organization with your  examples... more on that later.</p></li><li><p>Discuss several scenarios of making deposits and withdrawals  with you partner for each type of account. Make sure you understand  when the transaction cannot be completed (i.e., is invalid).</p></li><li><p>Add the method <tt>withdraw</tt> to the <tt>Account</tt> class and  implement it in each subclass:<pre>// EFFECT: Withdraw the given amount// Return the new balanceabstract int withdraw(int amount);</pre><p>When doing so we encounter a few questions:</p><ul><li><p><em>Question</em>: How do we signal that the transaction  cannot be completed?</p>    <p><em>Answer</em>: <tt>throw</tt> a <tt>new RuntimeException</tt>  similar to the following:</p>  <pre>throw new RuntimeException("Over credit limit");</pre><p>Make the message meaningful for your class. You may add someinformation about the account that caused the problem, the customername, or the current balance available.</p></li><li><p><em>Question</em>: How do we test that the method throws the  expected exception?</p>  <p><em>Answer</em>: Suppose the method invocation:</p><pre>this.check1.withdraw(1000)</pre><p>should throw a <tt>{RuntimeException</tt> with the message: <tt>"1000 is not available"</tt>. Our test for this exception would thenbe:</p>  <pre> t.checkException("Testing withdraw checking",    new RuntimeException("1000 is not available"),     this.check1,    "withdraw",    1000);</pre><p>The first argument is a <tt>String</tt> that describes what we are  testing --- it is optional and can be left out. The second argument  gives the <tt>Exception</tt> our method invocation should throw (the  messages must match exactly). The third argument is the instance  that invokes the method, the fourth argument is the method name.  After that we list as many arguments as the method consumes,  separated by commas.</p></li> <li><p><em>Question</em>: How do we test the correct method behavior  when the transaction goes through?</p>    <p><em>Answer</em>: We look at the purpose and effect  statements. Because the method produces a value as well an  <tt>effect</tt> (changes the state of the object), we must test both  aspects.</p>  <p>We first define instances and add them to our <tt>reset</tt> method.  We use the <tt>reset</tt> method to initialize our data since the  examples may change during each test.</p><pre>// Test the withdraw method(s)void testWithdraw(Tester t){  reset();  t.checkExpect(check1.withdraw(25), 75);  t.checkExpect(check1, new Checking(1, 75,                "First Checking Account", 20));  reset();}</pre><p>Notice that we use the <tt>reset</tt> method twice. At the start we makesure that the data we use has the correct values <em>before</em> thetests are invoked, and <em>after</em> the test(s) we reset the data tothe original values (since we always need to reset before testing, wecan leave the second reset off, though later we may need it if we do  other tasks before and after testing).</p><p>In this case there are two tests we have to perform: the first is whatwe have done in the past --- comparing the value produced by themethod with the expected value. The second test verifies that the<em>state</em> of the object did indeed change as expected.</p><p>Try the following <em>incorrect</em> implementations of the<tt>withdraw</tt> method in the <tt>Checking</tt> class to see why allthis testing is necessary:</p><pre>// Missing Effect...int withdraw(int amount){  return this.balance - amount;}</pre><pre>// Wrong return value...int withdraw(int amount){  this.balance = this.balance - amount;  return amount;}</pre><pre>// Correct, but no exception!int withdraw(int amount){  this.balance = this.balance - amount;  return this.balance;}</pre><p>Of course, we need to implement and test the method in each  <tt>Account</tt> class: the <tt>Savings</tt> and <tt>Credit</tt>classes as well.</p> </ul><li><p>Add the method <tt>deposit</tt> to the <tt>Account</tt> class and  implement it in all subclasses.  Remember, what happens in the  <tt>Credit</tt> case when the <tt>balance</tt> would become negative (no  more debt)?</p>     <pre>// EFFECT: Deposit the given funds into this account// Return the new balanceabstract int deposit(int funds);</pre><p>Make sure your tests are defined carefully as before.</p></ol>  <hr></hr><h3  class=section>2&nbsp;&nbsp;Methods that change the state of structured data.</h3><p>The <tt>Bank</tt> class keeps track of all accounts. </p> <ol>     <li><p>Design the method <tt>openAcct</tt> to <tt>Bank</tt> that allow the  customer to open a new account in the bank.  <pre>// EFFECT: Add a new account to this Bankvoid add(Account acct){ ... }</pre><p><strong>Make sure you design your tests carefully.</strong></p></li><li><p>Design the method <tt>deposit</tt> that deposits the given amount  to the account with the given name and account number.  Make sure  you <em>take exception</em> to any problems, e.g., no such account,  or a transaction that cannot be completed.</p><p><strong>Make sure you design your tests carefully.</strong></p></li><li><p>Design the method <tt>withdraw</tt> that withdraws the given  amount from the account with the given account number.  Make sure  you <em>take exception</em> to any problems, e.g., no such account,  or a transaction that cannot be completed.</p><p><strong>Make sure you design your tests carefully.</strong></p></li><li><p>Design the method <tt>removeAccount</tt> that will remove the  account with the given account number from the list of accounts in  this <tt>Bank</tt>.<pre>// EFFECT: Remove the given account from this Bankvoid removeAccount(int acctNo){ ... }</pre><p><em>Hint: Throw an exception if the account is not found, and    <strong>follow the Design Recipe!</strong></em></p></li></ol><hr></hr><h3  class=section>3&nbsp;&nbsp;Understanding Equality</h3><p><em>Note:</em> This material is covered in pages 321 - 330 in thetextbook. Read it carefully.</p><p>Our object is to define a method that will determine whether a given<tt>Account</tt> is the same as this <tt>account</tt>.  We may need such amethod to find a desired account within the <tt>Bank</tt>.</p><p>Of course, now that we have the abstract class it would be easy tocompare just account number and the name on the account, but we wantto make sure that all the customer's data matches what we have on fileexactly, including balances, interest rates, etc.</p><h3>Implementing <tt>same</tt></h3><p>We will design a <tt>same</tt> method similar to that described in thesecond part of the lecture, <em>Equality by safe casting</em>.  Therelevant examples can be found in the lecture notes. You may want tolook at the code there as you work through this problem.</p><ol><li><p>Begin by designing the method <tt>same</tt> for the <tt>Account</tt>  class.</p></li><li><p>Make examples that compare all kinds of accounts: of the same  kind (e.g., <tt>Checking</tt> vs. <tt>Checking</tt>) and of different  kinds (e.g., <tt>Savings</tt> vs. <tt>Credit</tt>). For the accounts of  the same kind you should test both <tt>true</tt> and <tt>false</tt>  cases. Comparing different kinds of accounts should always produce  <tt>false</tt>.</p></li> <li><p>Now that you have sufficient examples, follow with the design of  the <tt>same</tt> method in one of the concrete account classes  (for example the <tt>Checking</tt> class). Write the template and  think of what data and methods are available.</p></li><li><p>As in lecture, you need two different helper methods: one that  determines whether the given account is a  <tt>Checking</tt>, <tt>Savings</tt>, <tt>Credit</tt> account, and one that  converts this account into the desired type.  Design the methods  <tt>isChecking</tt>, <tt>isSavings</tt>, and <tt>isCredit</tt>, that  determine whether this account is a checking or savings or credit account,  respectively.</p></li><li><p>Design the methods <tt>toChecking</tt>, <tt>toSavings</tt>, and  <tt>toCredit</tt>, that convert this account into a  checking/savings/credit account, respectively.  Header and purpose  for the checking account case:</p><pre>// Convert this Account into a Checkingabstract Checking toChecking();</pre><p>In the <tt>Checking</tt> class the body will be just</p><pre>// Produce a checking account from this accountChecking toChecking(){  return this;}</pre><p>while the others should throw a <tt>RuntimeException</tt> with the  appropriate message.</p></li><li><p>Now we can define the body of the <tt>same</tt> method in the<tt>Checking</tt> class:</p><pre>// Is the given Account the same as this?boolean same(Account that){  if(that.isChecking()){    return this.sameChecking(that.toChecking());  }else{    return false;  }}</pre>  </li><li><p>We still need the method <tt>sameChecking</tt> but this only needs  to be defined within <tt>Checking</tt>, and can be defined with <tt>private</tt> (or <tt>protected</tt>) visibility.</p></li><li><p>Complete the design of the <tt>same</tt> methods (including <tt>sameChecking</tt>, <tt>sameSavings</tt>, <tt>sameCredit</tt>) for the  other two account classes.</p></li></ol><hr></hr><h3>Alternative approaches: bad and good</h3><ul><li><p><strong>Bad Option - Incorrect alternative:</strong></p><p>The method above can be incorrectly written with two features of theJava language: the <tt>instanceof</tt> operator and <em>casting</em>.In the <tt>Checking</tt> class this style method would look like thefollowing:</p><pre>// Is the given Account the same as this Checking?boolean same(Account that){  if(that instanceof Checking){    return this.sameChecking((Checking)that);  }else{    return false;  }}</pre><p><strong>However, this version introduces bugs!</strong></p><p>The issue is that any class that later extends <tt>Checking</tt>, say a<tt>PremiumChecking</tt> class, will also be considered a<tt>Checking</tt> instance by the <tt>instanceof</tt> operator.</p><p>If we implement a similar <tt>same</tt> method in<tt>PremiumChecking</tt>:</p> <pre>// Is the given Account the same as this PremiumChecking?boolean same(Account that){  if(that instanceof PremiumChecking){    return this.samePremChecking((PremiumChecking)that);  }else{    return false;  }}</pre><p>Then now only <tt>PremiumChecking</tt> objects can be the<tt>same</tt> as other <tt>PremiumChecking</tt> instances,<p><p><strong>But <tt>Checking</tt> instances can be the <tt>same</tt>    as <tt>PremiumChecking</tt> instances!!</strong></p><p>These kinds of bugs can cause serious problems.  This issue is alsoillustrated in the examplefile <a href="BadSame.java"><tt>BadSame.java</tt></a> from the labmain page.  You can add the file to your project and run the example,but we have included the <em>tester</em> output forillustration.</p></li><li><p><strong>Good Option - A Correct alternative:</strong></p><p>In lecture we introduced another version that also works. It requiresus to add a new method to the abstract class for each subclass of<tt>Account</tt>.</p>For our <tt>IShape</tt> hierarchy, the methods were:<pre>// Is that Circle the same as this Shape?public boolean sameCirc(Circ that);// Is that Rect the same as this Shape?public boolean sameRect(Rect that);// Is that Combo the same as this Shape?public boolean sameCombo(Combo that);</pre><p>This technique is popular in object-oriented languages likeJava and is known as <em>double dispatch</em>.</p></li></ul><hr></hr><!--Comment: ...--> <address></address><!-- hhmts start -->Last modified: Thu Feb 16 11:43:03 EST 2012 <!-- hhmts end --></body> </html>  </body></html>