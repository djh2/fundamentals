<html>  <head>    <title>CS 2510 Spring 2012: Lab12 - Stress Tests; HeapSort,  Priority Queue</title>  </head>    <h1>CS 2510 Spring 2012: Lab12 - Stress Tests; HeapSort,  Priority Queue</h1><h3>copyright 2012 Felleisen, Proulx, et. al.</h3>    <body><h4>Goals</h4><p>One goal of this lab is to learn how to implement the<em>heapsort</em> algorithm as well as the <em>priority queue</em>implemented as a heap. This is just a practice in understanding howone can convert a description of an algorithm into working code. Thesecond, more important goal of this lab is to illustrate on concreteexamples and experiences the differences in the algorithm complexity.</p><p>Homework assignment for this week is to finish anything you did notfinish during the lab and turn in your results.</p><P>Create a project with the name <tt>HW12Problem1</tt>. Download thefollowing files:</p> <ul>  <li><a href="student.zip">student.zip</a></li>  <li><a href="sorting.jar">sorting.jar</a></li>  <li><a href="citydb.txt">citydb.txt</a></li></ul><p>Unzip <em>student.zip</em> and import the whole folder you get(named <em>student</em>) into your project. Add <em>sorting.jar</em>to the classpath for your project. Finally, save the file<em>citydb.txt</em> in the same directory in your<em>EclipseWorkspace</em> where the <em>src</em> and <em>bin</em>files are stored for this project. Your project should be ready torun, but we will wait with that.</p><p><em>Note:</em>The filesin the <em>student.zip</em> file are saved in a folder named<em>student</em>. You have to import the whole folder into Eclipse. Itwill show up as a new <em>package</em> in your project. Notice thatboth files in this <em>package</em> starts with the declaration<tt>package student</tt>. This is the way Java programming languageallows you to combine together classes that belong together and form acomprehensive collection that can then be turned into a library.</p><p>Run the project using the <tt>TimerTests</tt> class as the classthat contains <tt>main</tt>. to make sure you have all pieces inplace. When the <em>file chooser dialog</em> comes up select the file<em>citydb.txt</em>.</p>  <h3>Priority Queue: Heap and Heapsort</h3><p>Our first goal in this section is to design a <em>priority queue</em>using the heap algorithm. We then use this to implement the<em>heapsort</em> algorithm and add it to a collection of algorithmsto be evaluated.</p><p><strong><em>Note:</em> If this part is taking too much time, put itaside and make sure you start the second half of thelab during the lab time, so that you know how to run the stresstests.</strong></p> <p>Recall the properties of the <em>Heap</em> from yesterday'slecture:</p> <ul><li><p>A <em>heap</em> is a complete binary tree. It means that every  level is filled, except for the last level. The last level is filled  from the left.</p>    <p>So a heap with five nodes will have the following shape:</p><pre>              node-1              /    \          node-2  node-3          /    \      node-4  node-5</pre><p>The nodes are labeled by levels from left to right, starting at 1.</p></li><li><p>The <em>value</em> in each node is greater-than or equal-to (for  some comparison definition) the values in both of its children. So  the item with the highest value (highest priority) is at the root of  the tree.</p></li>  <li><p>The label of the parent of node <tt>i</tt> is <tt>i/2</tt></p></li>  <li><p>The label of the left-child of node <tt>i</tt> is <tt>2*i</tt></p></li>  <li><p>The label of the right-child of node <tt>i</tt> is <tt>2*i+1</tt></li></p></ul><p>If it helps you, draw the picture of the tree and manipulate stickiesor pieces of paper to see how the algorithms for inserting anddeleting nodes work.</p><p>Typically, we represent this <em>heap</em> as an <tt>ArrayList&lt;T&gt;</tt>with the first item (at index 0) unused (maybe <tt>null</tt>).</p><ol><li><p>Add a <tt>HeapExamples</tt> class to your project.</p></li><li><p>Make three examples of the following <em>heap</em>s by defining  an <tt>ArrayList&lt;Integer&gt;</tt> for each case in your examples class  and an <tt>initHeaps</tt> method to add the values in the  appropriate order.</p></p>To build the following <em>heap</em><pre>                 node-1                /  70  \               /        \            node-2     node-3           /  60  \      40          /        \       node 4     node 5         35         50</pre><p>we would proceed as follows:</p><pre>ArrayList&lt;T&gt; myheap = new ArrayList&lt;T&gt;();void initHeap(){  this.myheap.add(null); // the unused first item  this.myheap.add(70);  this.myheap.add(60);  this.myheap.add(40);  this.myheap.add(35);  this.myheap.add(50);}</pre><p>Here are the three heaps to define:</p><pre>                 node-1               /   80   \              /          \          node-2         node-3         / 50 \         / 40        /      \       /     node-4   node-5  node-6       45       20      30</pre><pre>                  node-1                 /  50  \                /        \            node-2      node-3          /   45  \       40         /         \              node-4      node-5           30          20       </pre><pre>                  node-1                /   70  \               /         \           node-2         node-3           / 45 \         / 50          /      \       /      node-4  node-5   node-6        30      20      40</pre></li><li><p>Define the class <tt>PriorityQueue&lt;T&gt;</tt> that will represent a  <em>heap-based</em> priority queue. It has two fields: an  <tt>ArrayList&lt;T&gt;</tt> and a <tt>Comparator&lt;T&gt;</tt> that determines  the ordering of priorities.</p></li><li><P>Design the method <tt>isLeaf</tt> that consumes a node label (an  <tt>int</tt>) and returns <tt>true</tt> if the node has no children  (remember the numberings...).</li></p><li><p>Design the method <tt>higherPriorityChild</tt> that consumes the  index of a node that is not a <em>leaf</em> and produces the index  of its child with the highest priority.</p>  <p><em>Note:</em> If the node has only one child, then this will be the  one with the higher priority, of course.</p></li><li><p>Design the method <tt>insert</tt> that inserts a new node into  the <em>heap</em>.</p>  <p>Here is what we went over in lecture yesterday:</p>  <ul>  <li>Insert the new item at the next position in the bottom level    (the end of the list representation).  Say, this is position k.</li>   <li><p>Upheap from k:</p>     <pre>While (k > 1 and heap(k) > heap(k/2)) {  ~~~~~~swap heap(k) and heap(k/2)  ~~~~~~set k to k/2}     </pre>  </ul><li><p>Design the method <tt>remove</tt> that removes the node with the  highest priority from the <em>heap</em>.</p><p>Here is what we went over in lecture yesterday:</p>  <ul>  <li>save the <em>root</em> item as a temporary</li>  <li>move the <em>last</em> item into the root position</li>  <li>Downheap from k = 1:       <pre>While (k is not a leaf) {  ~~~~~~find ck the node with the larger child of the node k  ~~~~~~if heap(k) < heap(ck) {  ~~~~~~~~~~~~swap heap(k) and heap(ck)  ~~~~~~~~~~~~set k to ck }  ~~~~~~else stop  }     </pre></li> </ul> </ol><hr></hr> <h3>StressTests - Timing Tests</h3> <p>Your job is now to be an algorithm detective. The program we give youallows you to run any of the six different sorting algorithms on data sets offive different sizes  using three different <tt>Comparator</tt>sto define the ordering of the data. When you run the program, the timethat each of these algorithms took to complete the task is shown inthe console.</p><ol><li><p>Set up a new <em>Run Configuration</em> where you select the  class <tt>sorting.Interactions</tt> as the <em>Main</em> class. Run  the program. It will come up with a GUI with several buttons. You  need to use them in the correct order:<ul><li><p>Start with <em>File Input</em> button. It opens the <em>File  Chooser Dialog</em> and when you select the file  <strong>citydb.txt</strong> it reads in the data for the 29470 cities.</p></li><li><p>Next hit the <em>TimerInput</em> button. It lets you select which  algorithms to test, which <em>Comparator</em>s to use, and what  size data should be used in the tests.</p><p>Start with just a few small tests, to see how the program behaves,  before you decide to run all tests.</p><p>The last choice is <em>heapsort</em> that you have designed. The two files in the<tt>student</tt> package originally provided only hooks to the stress testprogram --- the method<tt>heapsort</tt> in the class<tt>Heapsort</tt>, so you could run the stress tests even if you did  not implement the <em>heapsort</em> algorithm. The original  <em>stub</em> just returned the original unsorted  <tt>ArrayList</tt>. So, <strong>if you are having difficulties with  finishing the implementation of the <em>heapsort</em></strong>, leave it for  now, and run the program with the original files in the  <tt>student</tt> package.</p> <li><p>In the third step, (once you read in the data and have chosen which  algorithms to run, for which data set sizes, and with which  <tt>Comparator</tt>s), you can run the actual timing tests by hitting  the <em>RunTests</em> button.</p></li><p>You can repeat the last two steps as many times as you want to.</p></ul></ol><strong>Exploration:</strong><p>Spend about fifteen minutes trying to answer some of the followingquestions. <em>Finish the work as a part of the Assignment 12.</em></p><p>Run the program a few times with small data sizes, to get familiarwith what it can do. Then run experiments and try to answer thefollowing questions:</p><ol><li><p>Which algorithms run mostly in quadratic time, i.e. <tt>O(n^2)</tt>?</p></li><li><p>Which algorithms run mostly in <tt>O(n.log_n)</tt> time?</p></li><li><p>Which algorithms use the functional style, using <tt>Cons</tt>  lists?</p></li><li><p>Which algorithm is the <em>selection sort</em>?</p></li><li><p>Why is there a difference when the algorithms use a different  <tt>Comparator</tt>?</p></li><li><p>Copy the results into a spreadsheet. You may save the result  portion in a text editor with a .csv suffix and open it in  <em>Excel</em> (or some other spreadsheet of your choice). You can now  study the data and represent the results as   charts. Do so for at least three algorithms, where there is one of  each --- a quadratic algorithm and a <em>linear-logarithmic</em>  algorithm.</p></li><li><p>Produce a report with a paragraph that explains what you learned,  using the <em>Excel</em> charts to illustrate this. </p></li></ol> <!--Comment: ...--> <address></address><!-- hhmts start -->Last modified: Thu Mar 29 11:12:23 EDT 2012 <!-- hhmts end --></body> </html>  </body></html>