<html>  <head>    <title>CS 2510 Spring 2012: Lab 8 - Abstracting over Datatypes; Understanding Javadocs</title>  </head>    <h1>CS 2510 Spring 2012: Lab 8 - Abstracting over Datatypes; Understanding Javadocs</h1><h3>copyright 2012 Felleisen, Proulx, et. al.</h3>    <body><h4>Goals</h4><p>The goal of this lab is to understand how we can design more general(generic) programs by defining/designing structured data parametrizedover the type of objects the data structure contains with the commonbehavior encoded as parametrized methods. We illustrate these ideas onrecursively built lists, but the techniques apply equally well to otherdata structures, such as binary trees and other data structures wewill see soon.</p><hr></hr><h3  class=section>1&nbsp;&nbsp;Parametrized Datatypes.</h3><p>Begin by downloading <a href="Lab8.zip">Lab8.zip</a> and building a project thatcontains all the files.Your project should have the following files:<ul><li>Book.java</li><li>Song.java</li><li>Image.java</li><li>ILo.java</li><li>ISelect.java</li><li>ExamplesLists.java</li><li>NoSuchElementException.java</li><li>ILoVisitor.java</li></ul><p>The last two files will be used in parts 2 and 3 of the lab - youcan ignore them at the beginning.</p>s<p>Run the project and make sure all tests pass, then workthrough the following exercises.</p><ol><li><p>The file <tt>ExamplesLists.java</tt> contains tests for the method  <tt>totalValue</tt> in the classes that represent lists of items of  the type <tt>T</tt>.</p>  <p>If you un-comment the <tt>testTotalValue</tt> method in the  <tt>ExamplesLists</tt>   class then the program breaks.  Modify the <tt>Book</tt>, <tt>Song</tt>,  and <tt>Image</tt> classes so that the method <tt>totalValue</tt> works  correctly for the list classes with items of the type <tt>Book</tt>,  <tt>Song</tt>, and <tt>Image</tt>, and all the tests pass.</p></li>  <li><p>Now design a method <tt>makeString</tt> for the list classes that  produces readable <tt>String</tt> representations of the elements of  type <tt>T</tt> in the list.</p>  <ul>  <li><p>Design a method <tt>makeString</tt> for each of <tt>Book</tt>,    <tt>Song</tt>, and <tt>Image</tt> that produces a <tt>String</tt>    representing all (or some of) the data in <tt>this</tt> instance of the class.    For example, you may construct a <tt>String</tt> that contains the    book title and author's name; the song's title and artist; etc.</p></li>  <li><p>Define an interface <tt>MakeString</tt> that represents a    <tt>makeString</tt> method.  As above, method implementations will produce    a <tt>String</tt> representation of the entire object, or a part of    it. </p> <p>Save it in the file <em>ILo.java</em></li>  <li><p>Design the method <tt>makeStrings</tt> for the list classes with    items of type <tt>T</tt> that produces a list of <tt>String</tt>s,    which is the result of applying the <tt>makeString</tt> method to every    item in the list.</p>    <p>Test your methods on the lists of books, songs, and images, in the    manner similar to that shown in the previous examples. </p></li>    </ul>    </li><li><p><strong>Warning:</strong> The examples you have seen are    <strong>bad</strong>. They force us to design a new interface for    every method that processes the items in the list, an require that    every class that wants to use it implement this interface. We    want to design a more general solution where we do not have to    change either the classes and interfaces that represent the list,    nor the classes that represent the items in the list. We also want    to avoid casting the data within the method, as this could lead to    runtime errors not detected by the type checker. </p>    <p>The next two     exercises and the last problem show you two different    <strong>better</strong> ways of doing this.</p><p>Think of the <em>Racket</em> function <tt>map</tt>. It consumes a list  of <tt>X</tt>, a function of the type <tt>X -> Y</tt>, and produces  a result of the type <tt>Y</tt> by applying the given function to  a  each item in the list.</p><pre>map: [Listof X] (X -> Y) -> [Listof Y](map (list x1 x2 ... xn) f) -> (list (f x1) (f x2) ... (f xn))</pre><p>So, our <tt>makeStrings</tt> method is a <tt>map</tt> from lists of the  type <tt>T</tt> (we used <tt>Song</tt>s, <tt>Book</tt>s, and  <tt>Image</tt>s) to lists of items of the type <tt>String</tt>.</p>  <ul>  <li><p>Design the interface <tt>ITransform< T, S></tt> that represents a    method <tt>transform</tt> that converts the given item of the type    <tt>T</tt> to an item of the type <tt>S</tt>. The interface will be    parametrized over two (possibly different) datatypes, <tt>T</tt> and    <tt>S</tt>. Save this in a file names <em>ITransform.java</em> </p></li>  <li><p>Design three classes that implement this interface as follows:    <ul>    <li>from the type <tt>Book</tt> to the type <tt>String</tt> e.g. the      book title</li>    <li>from the type <tt>Image</tt> to the type <tt>Integer</tt>,      e.g. the image size, or width, or height</li>    <li>from the type <tt>Song</tt> to the type <tt>Boolean</tt>,      e.g. by the given artist, or short song...)</li>    </ul>    <p>Save them in the same file, i.e. <em>ITransform.java</em></p>        <p>Notice that we use the types <tt>Integer</tt> and    <tt>Boolean</tt> instead of the primitive types <tt><strong>int</strong></tt> and    <tt><strong>boolean</strong></tt>.  These upper-case types are so called    <em>wrapper classes</em> (or <em>boxed</em> types) that allow us    to use a primitive data type as if it were a regularly defined    class.</p>    <p>Java automatically converts instances of these classes to and from    their primitive values when required, so primitive values may be    used where the wrapper type is required and vice versa.  There is    one exception: <em><strong>only the wrapper classes may be used as      type parameters</strong></em>, i.e., you cannot have an instance of    <tt>ILo<<strong>int</strong>></tt>.</p></li>  <li><p>Design the method <tt>map</tt> for the classes that represent a    list of items of the type <tt>T</tt>. The method header will be:<pre>// Produce a list with items of type S from this//   list  of items of type T by applying the//   given function to every item in this listpublic < S> ILo< S> map(ITransform< T, S> transform);</pre>    <p>Make examples for this method that produce a list of book    titles in a list of books, a list of image sizes from the list of    images, and a list of artist names from the list of songs.</p></li></ul><li><p>We would like to generalize the method <tt>filter</tt> we have  seen previously so that it works for arbitrary lists of items.  The  method produces a list of all items that satisfy some predicate.  We  modify the <tt>ISelect</tt> interface so it can be applied to any type  of data:</p><pre>   // a method to decide whether this item    // has the desired property   interface ISelect< T>{      // does this data item have the desired property?      public boolean select(T data);   }</pre><p>Design the method <tt>filter</tt> that produces a list of allitems in the list (parametrized by the type <tt>T</tt>) that satisfy thegiven predicate (an instance of a class that implements the<tt>ISelect<T></tt> interface). Test it by selecting all books that costless than $25, all songs that play for more than 180 seconds, and allimages with the <em>"jpeg"</em> file type.</p></li>  <p><strong>You will finish this last problem as a part of your nexthomework.</strong></p> </ol><h3  class=section>2&nbsp;&nbsp;User-Defined Exceptions.</h3><p>We will learn how to design our own exception classes, and how  the program can recover after an exception has been thrown during  the program execution. After all, you would not want a long running  program that processes thousands of transactions stop every time it  encounters some incorrect input data. You will define your own  <tt>NoSuchElementException</tt> class, a method that <em>throws</em>  this kind of exception, another method that invokes it and  <em>catches</em> the exception and allows us to continue running the  program.</p>   <p>The class <tt>NoSuchElementException</tt> included in the  <em>Lab8.zip</em> files is a user-defined class that  extends the <tt>Exception</tt>   class defined in the Java libraries. The template for the exception  classes is always the same - for the standard cases the programmer  just decides on the name of the exception class.</p><p>The class  <tt>RuntimeException</tt> we have seen in the earlier labs also  extends the Java <tt>Exception</tt>  class. When the method throws the  <tt>RuntimeException</tt>, (or an exception from any of the classes  that extend the <tt>RuntimeException</tt>) the programmer does not  have to note that the method may fail. The faults that trigger  throwing the <tt>RuntimeException</tt> are typically such that  testing for their occurrence would be too time-consuming and these  faults should not occur in   well-designed programs. However, if the method throws an exception  that is not a subclass of the <tt>RuntimeException</tt>, the  programmer must make this seen in the method header, and any program  that invokes this method must include the code that specifies what  the method should do if the exception is thrown. Here is an example:</p>  <p>The following method indicated that it may throw an exception:</p><pre>// produce the author of this book// throw an exception if no name is knownpublic String authorName() throws NoSuchElementException{  if (this.author.equals(""))    throw new NoSuchElementException(              "No author for the book " + this.title);  else    return this.author;}</pre><p>and when invoked, the programmer must include the <tt>try -catch</tt> clause as follows:</p><pre>// test for the method that throws an exception// using the try-catch clausevoid testAuthorName(Tester t){  Book noAuthor = new Book("The Bible", "", 20);  try{    t.checkExpect(noAuthor.authorName(), "");  }  catch(NoSuchElementException e){    t.checkExpect(e.getMessage(), "No author for the book The Bible");  }}</pre><p>As you can see, the <tt>catch</tt> part looks like a methodinvocation that consumes an instance tt>e</tt> of the desired<tt>Exception</tt> class. This instance can then invoke the method<tt>e.getMessage()</tt> to extract the message that the program producedwhen the exception was thrown.</p> <p>Design the method <tt>findItem</tt> that produces the first item inthis list that satisfies the given predicate. If there is no suchitem, throw an <tt>NoSuchElementException</tt> as follows:</p><ul>  <li><p>Design the method <tt>findItem</tt> with the <tt>throws</tt>  clause.</p></li>  <li><p>Design tests for this method that uses the  <tt>checkExpect</tt> method within the <tt>try - catch</tt> clause  in the manner similar to our example.</p>  <li><p>Add tests that use the <tt>checkException</tt> test in the  <em>tester</em> library.</p></li></ul><p><strong>You will finish this problem as a part of your next homework.</strong></p><h3  class=section>3&nbsp;&nbsp;Visitors.</h3><p>We often do not know what kinds of methods the programmers need todefine for their lists of objects. Furthermore, they may have to defineone specific method for their list that is not applicable to any otherlist of objects. Here is an example:</p><p> We may want to use these classes for our circularly defineddata. So we may want to add the method <tt>addBook</tt> to the classesthat represent the list of authors (or <tt>addRole</tt> to the classesthat represent the list of movie actors).</p><p>To makethe library extensible, the designers need to provide ways for addingnew methods at the time the programmer wants to use it. </p><p>One way to make the self-referential union of classes extensible isby defining a <em>visitor</em> interface and add to the union a methodthat invokes the methods of the <em>visitor</em> interface supplyingits own internal data as arguments. This sounds very complicated. Wewill illustrate this on an example.</p><p>Here is an example of a <em>visitor</em> interface for the classesthat define a list of objects:</p><pre>// A visitor for the ILo<T> classes that // and produces the result of the type Rinterface ILoVisitor<R, T>{  // method for the empty list  public R forMt();     // method for the nonempty list  public R forCons(T first, ILo<T> rest);}</pre><p>The <em>visitor</em> for a union of data types contains one methodfor every class in the union, and has the name that indicates theclass it <em>targets</em>. The arguments for each method are thefields in the <em>target</em> class that are needed to perform anyoperations on an object in this field. So, here, the method<tt>forMt</tt> takes no arguments, as there are no relevant fields inthe class <tt>MtLo< T></tt>. On the other hand, the method<tt>forCons</tt> consumes the <tt>first</tt> and the <tt>rest</tt>,where the <tt>first</tt> is of the type < T> and the <tt>rest</tt> isof the type <tt>ConsLo< T></tt>.<p><p>We now add to the classes <tt>MtLo< T></tt> and <tt>ConsLo< T></tt>the <em>hooks</em>, the methods that accept the instance of thevisitor class and invoke the appropriate methods defined there:</p><pre>// in the interface ILo< T>:// accept the visitor that produces a result of the type Rpublic < R> R accept(ILoVisitor< R, T> ilov);// in the class MtLo< T>:// accept the visitor that produces a result of the type Rpublic < R> R accept(ILoVisitor< R, T> ilov){  return ilov.forMtLo();}// in the class MtLo< T>:// accept the visitor that produces a result of the type Rpublic < R> R accept(ILoVisitor< R, T> ilov){  return ilov.forConsLo(this.first, this.rest);}</pre><p>The example included in the <em>Lab8.zip</em> files defines avisitor that represents a method that computes the total download timefor all files in the list of image files</p><p>The visitor class is defined as follows:</p><pre>// A visitor that computes the total download time for all files // in the list of image filesclass ILoImageDownloadTimeVisitor   implements ILoVisitor<Integer, Image>{    int speed;  ILoImageDownloadTimeVisitor(int speed){    this.speed = speed;  }  // method for the empty list  public Integer forMt(){    return 0;  }    // method for the nonempty list  public Integer forCons(Image first, ILo<Image> rest){    return         first.fileSize / speed + rest.accept(this);  }}</pre><p>The following examples show how we can use this method with ourlists of data:</p><pre>ILoVisitor<Integer, Image> imageDownloads =         new ILoImageDownloadTimeVisitor(200);    // test the use of the ILoMakeStringVisitorvoid testILoMakeStringVisitor(Tester t){  t.checkExpect(this.mtloi.accept(this.imageDownloads), 0);  t.checkExpect(this.ilist2.accept(this.imageDownloads), 287);      }</pre><p>We see that the methods defined in the class that implements the<em>visitor</em> have the same structure as those originally definedinside of the <tt>MtLo...</tt> and <tt>ConsLo...</tt> classes. Theinstance of the list then invokes the new method by applying the<tt>accept</tt> method with the appropriate visitor as itsargument.</p><ol><li><p>Make another example of the use of the  <tt>ILoImageDownloadTimeVisitor</tt> that computes the download time  with the download speed 100 for the list <tt>ilist3</tt>.</p></li><li><p>Design a visitor that implements the method that produces a  list of titles of all songs in a list of songs. Of course, you need  to make sure that your solution works.</p></li><li>Design a visitor that implements the method that produces one long  <tt>String</tt> that contains the titles of all books, separating  the titles with the new line <tt>String</tt> that is encoded as  <tt>"\n"</tt>. Of course, you need  to make sure that your solution works.</p></li></ol><p>We could now rewrite the solution to the circularly referentialproblem af books and authors (or actors with movie roles) using thegeneric list of objects and adding the appropriate visitor to the listof authors (or actors). Work this out on your own as a practiceproblem - it is not a required part.</p><p><strong>You will finish this problem as a part of your next homework.</strong></p><h3  class=section>4&nbsp;&nbsp;Reading/Using Java Documentation.</h3><p>Until now, our purpose statements were sufficient for someone tryingto understand how our program works and where to make changes, even ifanother person wanted to improve the program we have written.  However,if we design a program that represents a reusable datatype, such aslists or binary search trees parametrized over the type of data theycontain, a client of our code may not be interested in theimplementation details, only the fields, constructors, and methodsthat can be used, called, or overridden.</p><p>Most modern general-purpose programming languages come with a special(embedded) language for writing purpose statements that can then betranslated into documentation.  Typically the documentation is generatedas cross-referenced web pages, which allow the client programmer tounderstand and use the library without looking at actual code.</p><h4>JavaDoc Basics</h4><ol><li><p>Go to the <em>javalib</em> web site: <a  href="http://www.ccs.neu.edu/javalib">http://www.ccs.neu.edu/javalib</a></p>  <p>Go to the<em>Tester</em> link on the left, then look at  <em>JavaDocs</em> tab and open the documentation for the latest  version of the <em>tester</em> library. The web site you see has the  documentation for all public fields and methods in the library.  Click on the <em>Tester</em> tab in the left pane and you will see a  description of the <tt>Tester</tt> class.</p></li><li><p>Scroll through the descriptions of the methods until you find  the documentation for <tt>checkInexact</tt>. Click on the method and  you will see a detailed description of the method - its purpose, its  parameters, and the return value it produces. </p></li><li><p>Now look at the method <tt>checkRange</tt> in the <em>Method  Summary</em> section. You can see that there is a number of methods with  this name: some that consume an argument of the type  <tt>java.lang.Comparable< T></tt> and some that consume an argument of  the type <tt>java.util.Comparator< T></tt>.</p>  <p>These are two interfaces defined in standard Java libraries. The  first is a part of the Java language package (<tt>java.lang</tt>). The  classes and interfaces defined there are automatically imported for  every Java program.  For example, the class <tt>String</tt> is  specified in the documentation as <tt>java.lang.String</tt>; we have  been using it all along without the need for specific <tt>import</tt>  statements.</p>  <p>The interface <tt>java.util.Comparator< T></tt> is a part of the  <tt>java.util</tt> package in the <strong>Java Collections  Framework</strong>: a library of classes and interfaces for dealing  with collections of data. </p></li></ol>  <hr></hr><!--Comment: ...--><address></address><!-- hhmts start -->Last modified: Mon Feb 27 22:05:14 EST 2012 <!-- hhmts end --></body> </html>  </body></html>