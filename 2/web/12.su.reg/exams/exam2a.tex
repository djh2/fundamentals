\documentclass[11pt]{article}

%% ------------------------------------------------------------------
%% SOLUTIONS:
\def\thel{\noindent\rule{2.5cm}{.5pt}}
\long\def\begsol#1 #2\endsol{#1}
% \def\begsol#1{\thel {\bf Solution} \thel}\def\endsol{\relax}
%%uncomment the above line to get the solutions printed

\newcommand\code[1]{\texttt{#1}}
\newcommand\bcode[1]{\texttt{\textbf{#1}}}

%% PROBLEMS:
\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
\newcounter{Pctr}
\newenvironment{problem}{\stepcounter{Pctr}%
\begin{description}
\item[\noindent{\bf Problem} \arabic{Pctr}] 
\end{description}}{\relax}
%% ------------------------------------------------------------------

%% SUBPARTS:
\newcounter{parts}
\renewcommand{\theparts}{\Alph}
%% ------------------------------------------------------------------

\begin{document}

\renewcommand{\theenumi}{\Alph{enumi}}
\setcounter{Pctr}{0}

%% ------------------------------------------------------------------

\vfill
\centerline{\Large CS 2510 Exam 2 -- Spring 2012}

~\\[2cm]

\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{200pt}{.1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{200pt}{.1pt} \\[.5cm]
\end{tabular}
\end{center}

\noindent\begin{minipage}{7.5cm} $\bullet$ Write down the answers in the
space provided. 

$\bullet$ You may use all syntax that you know from \textit{FunJava}
(that is, the parts of Java we have studied in class), although there
are several features you will \emph{not} need.

$\bullet$ When defining methods, you do not need to give a complete
class definition---just indicate in which class your method definition
should be placed.

$\bullet$ For tests you only need to provide the expression that
computes the actual value, connecting it with an arrow to the expected
value. For example \code{s.method() -> true} is sufficient.

$\bullet$ Remember that the phrase ``design a class'' or ``design a
method'' means more than just providing a definition. It means to
design them according to the \textbf{design recipe}.  You are
\textit{not} required to provide a method template unless the problem
specifically asks for one.  However, be prepared to struggle if you
choose to skip the template step.

$\bullet$ We will not answer \textit{any} questions during the exam.

\bigskip

\textit{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{4.5cm}
\begin{tabular}{|c|l|@/r|}
\hline
\textbf{Problem} & Points & \\ \hline
A & & 5\\ \hline
B & & 5\\ \hline
C & & 10\\ \hline
D & & 10\\ \hline
\textbf{Total} &  & 30 \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

%% -----------------------------------------------------------------------------
%% 
\pts{34}
\begin{problem}
Amateur radio (aka ham radio) broadcasts work as follow: there are
three kinds of transmitter nodes: those that simply transmit a signal
to another node, those that split a signal and transmit it to two
other nodes, and finally those that are the end points of
communication that don't broadcast any further.  When a broadcast goes
out, the network is set up in such a way that no broadcast goes to the
same node twice (there are no cycles in the network).

The following class diagram represents a radio broadcast network:

\begin{verbatim}
                     +--------------+<-------------------------+
                     |    Node<T>   |<-----------------------+ |
                     +--------------+<---------------------+ | |
                     | T data       |                      | | |
                     +--------------+                      | | |
                     / \   / \   / \                       | | |
                     ---   ---   ---                       | | |
                      |     |     |                        | | |
        +-------------+     |     +-----------+            | | |
        |                   |                 |            | | |
        |                   |                 |            | | |
 +-------------+      +--------------+  +---------------+  | | |
 | Terminal<T> |      | Repeat<T>    |  | Split<T>      |  | | |
 +-------------+      +--------------+  +---------------+  | | |
                   +--| Node<T> next |  | Node<T> left  |--+ | |
                   |  +--------------+  | Node<T> right |----+ |
                   |                    +---------------+      |
                   +-------------------------------------------+
\end{verbatim}


\begin{enumerate}


\newpage
%-----------------------------------------------
\item {\em{(5 points)}}

Here is a graphical view of a local ham radio network:

\begin{verbatim}
           "NEU"
          /     \
         /       \
   "CCIS"         "CE"
      |           / |
   "Clubs"       /  |
    /   \       /   |
"NUACM" "CISters"  "Robotics"
               \    /
                \  /
            "Robocisters"
\end{verbatim}

When a node appears above another with a line between them, it means
the upper node broadcasts to the lower one.  The strings given show
the data each node carries.

Translate the above information into examples of data that represent
the network.

\begsol{\vspace{0.5in}}
\begin{verbatim}
Node<String> rc = new Terminal<String>("Robocisters");
Node<String> rs = new Repeat<String>("Robotics", rc);
Node<String> cs = new Repeat<String>("CISters", rs);
Node<String> ce = new Split<String>("CE", cs, rs);
Node<String> nu = new Terminal<String>("NUACM");
Node<String> cb = new Split<String>("Clubs", nu, cs);
Node<String> is = new Repeat<String>("CCIS", cb);
Node<String> ne = new Split<String>("NEU", is, ce);
\end{verbatim}

\endsol

\newpage
\item  {\em{(5 points)}}

Here is the data representation of another network (this one carries
integers rather than strings):

\begin{verbatim}
Node<Integer> h = new Terminal<Integer>(800);
Node<Integer> b = new Terminal<Integer>(12);
Node<Integer> a = new Split<Integer>(1, h, b);
Node<Integer> z = new Terminal<Integer>(7);
Node<Integer> c = new Split<Integer>(9, z, a);
Node<Integer> j = new Repeat<Integer>(11, a);
Node<Integer> d = new Repeat<Integer>(44, j);
Node<Integer> g = new Split<Integer>(19, c, d);
Node<Integer> t = new Terminal<Integer>(4);
Node<Integer> s = new Split<Integer>(13, t, c);
Node<Integer> k = new Split<Integer>(14, s, g);
\end{verbatim}

Translate the above into a graphical representation of the network
similar to that given in part A.

\begsol{\vspace{0.5in}}
\begin{verbatim}
     14
    /   \
   /     19
  /    /   \
 13   |    44     
 |  \ /    |     
 4   9     11  
     / \  /
    7   1 
       /  \
     800   12
\end{verbatim}
\endsol


\newpage
%-----------------------------------------------
\item {\em{(10 points)}}

One measure of the networks robustness is the number of paths from 
a node to any terminal.

Design the method {\tt countAllPaths} that computes the number of
paths from this node to a terminal node.

\begsol{\vspace{0.5in}}
\begin{verbatim}
// in Node<T>
// count all possible paths from this node to any terminal
abstract public int countAllPaths();

// in Terminal<T>
public int countAllPaths() {
   return 1;
}

// in Repeat<T>
public int countAllPaths() {
   return this.next.countAllPaths();
}

// in Split<T>
public int countAllPaths() {
   return this.left.countAllPaths() + this.right.countAllPaths();
}

rc.countAllPaths() -> 1
rs.countAllPaths() -> 1
ce.countAllPaths() -> 2
\end{verbatim}
\endsol

\newpage
%-----------------------------------------------
\item {\em{(10 points)}}

The quality of radio transmissions deteriorate as they are broadcast
across more and more nodes.  We would like to measure the degree of
distortion in a network.

Design the method {\tt distanceTo} that finds the length of the
shortest network route from this node to the node containing the given
data.

\begsol{\vspace{0.5in}}
\begin{verbatim}
// In Node<T>
// compute the length of the path to the node with the given data 
abstract public int distanceTo(T data);

// compute the length of the path to the node with the given data
public int distanceTo(T data){
  if (this.data.equals(data))
    return 1;
  else
    return 1000; // nonsense value - we will never have 1000 nodes
}

// compute the length of the path to the node with the given data
public int distanceTo(T data){
  if (this.data.equals(data))
    return 1;
  else
    return 1 + this.next.distanceTo(data);
}

// compute the length of the path to the node with the given data
public int distanceTo(T data){
  if (this.data.equals(data))
    return 1;
  else
    return 1 + Math.min(this.left.distanceTo(data), 
                        this.right.distanceTo(data));
}

// PLUS TESTS
\end{verbatim}
\endsol

\newpage
%-----------------------------------------------
\end{enumerate}
\end{problem}
\end{document}

