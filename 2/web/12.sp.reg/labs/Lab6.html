<html>  <head>    <title>CS 2510 Spring 2012: Lab 6 - Understanding Constructors; Function Objects</title>  </head>    <h1>CS 2510 Spring 2012: Lab 6 - Understanding Constructors; Function Objects</h1><h3>copyright 2012 Felleisen, Proulx, et. al.</h3>    <body><h4>Goals</h4><p>In the first part of this lab we will learn to design constructors thatprovide better user interface and at the same time assure theintegrity of the data that the instances of the class represent.</p><p>In the second part of the lab we will learn to design and use<em>function objects</em>, the Java technique for parametrizingfunctional behavior.</p><hr></hr><h3  class=section>1&nbsp;&nbsp;Understanding Constructors.</h3><p> Start a new project named <tt>Lab6-Date</tt> and import into  it the file <a href="Date.java">Date.java</a>. </p><p>Standard Java asks  that programmers define every <tt>public</tt> class in a file with  the same name as the name of the class, followed by  <tt>.java</tt>. We will now follow this convention. Define a new  file in your project (in menu <em>New -> File</em>) and name it  <tt>ExamplesDate.java</tt>. As you can guess, this will be your  <em>Examples</em> class. Add at least three examples of valid dates  to this class., and set up a <em>Run configuration</em> to run  it.</p><hr></hr><h4>Overloading Constructors: Assuring Data Integrity.</h4><p>The data definitions at times do not capture the meaning of data andthe restrictions on what values can be used to initialize differentfields. For example, if we have a class that represents a date in thecalendar using three integers for the day, month, and year, we knowthat our program is interested only in some years (maybe between theyears 1500 and 2500), the month must be between 1 and 12, and the daymust be between 1 and 31 (though there are additional restrictions onthe day, depending on the month and whether we are in a leapyear). </p> <p>Suppose we make the following <tt>Date</tt> examples:</p><pre>// Good datesDate d20100228 = new Date(2010, 2, 28); // Feb 28, 2010     Date d20091012 = new Date(2009, 10, 12);// Oct 12, 2009// Bad dateDate dn303323 = new Date(-30, 33, 23);</pre><p>Of course, the third example is just nonsense.  Whilecomplete validation of dates (months, leap-years, etc...) is a coursematerial itself, for the purposes of practicing constructors, wewill simply make sure that the month is between 1 and 12, the day isbetween 1 and 31, and the year is between 1500 and 50000 <em>we're thinking ahead!</em></p><p>Did you notice the repetition in the description of validity? Itsuggests we start with a few helper methods <em>(early abstraction)</em>:</p><ul><li><p> Design the method <tt>validNumber</tt> that consumes a number and the low and  high bound and returns <tt>true</tt> if the number is within the  bounds (inclusive).</p></li><li><p> Design the methods <tt>validDay</tt>, <tt>validMonth</tt>, and <tt>validYear</tt>  designed in a similar manner.</p></li></ul><p>Do this quickly - do not spend much time on it - maybe do just themethod <tt>validDay</tt> and leave the rest for later - for now justreturniong <tt>true</tt> regardless of the input. <em>(Such temporarymethod bodies are called <strong>stubs</strong>, their goal is to makethe rest of program design possible.)</em></p><p>Now change the <tt>Date</tt> constructor to the following:</p><pre>Date(int year, int month, int day){   if(this.validYear(year))      this.year = year;   else      throw new IllegalArgumentException("Invalid year");   if(this.validMonth(month))      this.month = month;   else      throw new IllegalArgumentException("Invalid month");   if(this.validDay(day))      this.day = day;   else      throw new IllegalArgumentException("Invalid day");}</pre><p> This is similar to the constructors for the <tt>Time</tt> class we saw in lectures.To signal an error or some other <em>exceptional</em> condition, we<tt>throw</tt> an instance of <tt>RuntimeException</tt>. We elected touse the instance of the <tt>IllegalArgumentException</tt>, which is asubclass of the <tt>RuntimeException</tt>.</p><p>If the program ever executes a statement like:</p><pre>throw new ...Exception("... message ...");</pre><p>Java <em>raises</em> the constructed exception/error.For our purposes now, this is as good as terminating the program andprinting the message string.</p><hr></hr><p>The <em>tester</em> library provides methods to testconstructors that should throw exceptions:</p><pre>  boolean t.checkConstructorException(Exception e,                                      String className,                                       ... constr args ...);</pre><p>For example, the following test case verifies that ourconstructor throws the correct exception with the expected message, ifthe supplied year is <tt>53000</tt>:</p><pre>   t.checkConstructorException(            new IllegalArgumentException("Invalid year"),            "Date",            53000, 12, 30);</pre><p>Run your program with this test. Now change the test byproviding an incorrect message, incorrect exception(e.g. <tt>NoSuchElementException</tt>), or by supplying arguments thatdo not cause an error, and see that the test(s) fail.</p><p>Java provides the class <tt>RuntimeException</tt> with a number ofsubclasses that can be used to signal different types of dynamicerrors.  Later we will learn how to handle errors and design newsubclasses of <tt>RuntimeException</tt> to signal errors specific to ourprograms.</p><h4>Overloading Constructors: ProvidingDefaults.</h4><p>When entering dates for the current year it is tedious to continuallyenter <tt>2011</tt>. We can provide an additional constructor that onlyrequires the <tt>month</tt> and <tt>day</tt>, assuming the year should be<tt>2011</tt>.</p><p>Remembering the <em>single point of control</em> rule, we make surethat the new <em>overloaded</em> constructor defers all of the work tothe primary <em>full</em> constructor:</p><pre>Date(int month, int day){  this(2011, month, day); }</pre><p>Add examples that use only the month and day to see that theconstructor works properly. Include tests with invalid month or yearas well.</p><h4>Overloading Constructors: Expanding Options.</h4><p>The user may want to enter the date in the form: <tt>"Oct 20  2010"</tt>.  To make this possible, we can add another constructor:</p><pre>Date(String month, int day, int year){  ...}</pre><pre>Our first task is to convert a <tt>String</tt> that representsa month into a number. We can do it in a helper method<tt>getMonthNo</tt>:</pre><pre>// Convert a three letter month into the numeric valueint getMonthNo(String month){  if(month.equals("Jan")){ return 1; }  else{ if (month.equals("Feb")){ return 2; }  else{ if (month.equals("Mar")){ return 3; }  else{ if (month.equals("Apr")){ return 4; }          ...  else    throw new IllegalArgumentException("Invalid month");}</pre><p>Our constructor can then invoke this method as follows:</p><pre>   Date(String month, int day, int year){      // Invoke the prinmary constructor, with a valid month      this(year, 1, day);        // Change the month to the given one      this.month = this.getMonthNo(month);   }</pre><p>Complete the implementation, and check that it workscorrectly.</p><hr></hr><h3  class=section>2&nbsp;&nbsp;Abstracting with Function Objects</h3><p>Download the files in <a href="Lab6.zip">Lab6.zip</a>. The foldercontains the files:</p><ul><li>ImageFile.java</li><!-- <li>ISelectImageFile.java</li> --><!-- <li>SmallImageFile.java</li> --><li>ILoIF.java</li><li>MTLoIF.java</li><li>ConsLoIF.java</li><li>ImageFileExamples.java</li></ul><p>Starting with partially defined classes and examples will give you theopportunity to focus on the new material and eliminate typing in whatyou already know. However, make sure you understand how the class isdefined, what does the data represent, and how the examples wereconstructed.</p><p>Create a new project <em>Lab6-FunctionObjects</em> and import into itall of the given files. Also add <em>tester.jar</em> to the Java classpath.<hr></hr><h4>Introduction -- Tutorial</h4><p>We start by designing three familiar methods that deal with lists offiles: <tt>filterSmallerThan40000</tt>, <tt>filterNamesShorterThan4</tt>,<tt>countSmallerThan40000</tt>.</p><p>Look at the first two methods. They should only differ in the body ofthe conditional in the class <tt>ConsListImage</tt>. The two versionslook like this:</p><pre> if (this.first.size() < 40000) if (this.first.name.length() < 4)</pre><p>Both represent a boolean expression that depends only on the valueof <tt>this.first</tt>. Think about the <tt>filter</tt> loop functionin <em>DrRacket</em>. Its contract and header were:</p> <pre>;; filter: (X -> boolean) [Listof X] -> [Listof X];; to construct a list from all those items ;; in alox for which p holds(define (filter p alox)...)</pre><p>The argument <tt>p</tt> was a function/predicate that consumed anitem from the list (for example the <tt>first</tt>) and produced aboolean value that indicated whether the item is<tt>acceptable</tt>.</p> <p>Java does not allow us to use functions or methods as arguments. Toget around this problem we need to go through several steps:</p> <ul><li><p>Define an interface that contains as its only method the header for the desired predicate: the interface <tt>ISelectImageFile</tt>:</p><pre>// to represent a predicate for ImageFile-spublic interface ISelectImageFile{  // Return true if the given ImageFile   // should be selected   public boolean select(ImageFile f);}</pre></li><li><p>Now any class that implements this interface will have thispredicate method. Suppose our <tt>filter</tt> method consumes anobject of the type <tt>ISelectImageFile</tt> as follows:</p> <pre>// produce a list of ImageFiles from this list // that satisfy the given predicatepublic filter(ISelectImageFile pick);</pre><p>Inside the method <tt>filter</tt> our template now includes</p><p><tt>... pick.select(ImageFile) ...  -- boolean</tt></p><p>and so, we can replace the two conditionals by</p><pre>if (pick.select(this.first))</pre></li><li><p> We now need to define a class that implements this interface. It needs to define the method <tt>select</tt> that consumes an instance of <tt>ImageFile</tt> and returns <tt>true</tt> if the size of the given object is less than <tt>40000</tt>. The following class definition accomplishes this task:</p><pre>/* Select image files smaller than 40000 */public class SmallImageFile implements ISelectImageFile {    /* Return true if the given ImageFile is smaller than 40000 */  public boolean select(ImageFile f) {    return f.height * f.width < 40000;  }}</pre></li><li><p>In the <tt>Examples</tt> class we can now invoke the<tt>filter</tt> method on an <tt>IListImageFile</tt> with an instanceof <tt>SmallImageFile</tt> as the argument:</p> <pre>IListImageFile mtImagelist = new MTListImageFile();IListImageFile imagelist = .....IListImageFile smallImagelist = ...ISelectImageFile smallFiles = new SmallImageFile();// test the method filter on small image filesboolean testFilter(Tester t){  return  t.checkExpect(mtImagelist.filter(this.smallFiles),                 this.mtImagelist) &&  t.checkExpect(imageList.filter(this.smallFiles),                 this.smallImagelist);}</pre><p>The conditional inside the <tt>filter</tt> method:</p><pre>if (pick.select(this.first))</pre><p>will select the <tt>ImageFile</tt> objects for which the size issmaller than <tt>40000</tt>.</p> </li></ul><p>The file <a href="Diagram.txt">Diagram.txt</a> shows the classdiagram for these classes and interfaces. It introduces a dotted lineto indicate that the argument for a method is an instance of anotherclass or interface.</p><p><em>Make sure you view the image using a fixed-width font.</em></p><hr></hr><h4>Practice</h4><p>We will now practice the use of <tt>function objects</tt>. The onlypurpose for defining the class <tt>SmallImageFile</tt> is to implementone method that determines whether the given <tt>ImageFile</tt> objecthas the desired property (a predicate method). An instance of thisclass can then be used as an argument to a method that deals with<tt>ImageFile</tt>s.</p> <ol><li><p>Start with defining in the <tt>ExamplesImageFile</tt> class the  missing tests for the class <tt>SmallImageFile</tt>.</p></li> <li><p>Design the method <tt>allSmallerThan40000</tt> that determines  whether all items in a list are smaller that 40000 pixels. The  method should take an instance of the class <tt>SmallImageFile</tt>  as an argument.</p></li> <li><p>We now want to determine whether the name in the given  <tt>ImageFile</tt>  object is shorter than 4. Design the class  <tt>NameShorterThan4</tt> that implements the  <tt>ISelectImageFile</tt> interface with an appropriate predicate  method.</p> <p>Make sure in the class <tt>ExamplesImageFile</tt> you define an  instance of this class and test the method.</p></li> <li><p>Design the method <tt>allNamesShorterThan4</tt> that determineswhether all items in a list have a name that is shorter than 4characters. The method should take an instance of the class <tt>NameShorterThan4</tt> as an argument.</p></li><li><p>Design the method <tt>allSuchImageFile</tt> that thatdetermines whether all items in a list satisfy the predicate definedby the <tt>select</tt> method of a given instance of the type<tt>ISelectImageFile</tt>.</p><p><em>Note: This resembles the andmapfunction in DrRacket.</em> In the <tt>ExamplesImageFile</tt>class test this method by abstracting over the method<tt>allSmallerThan40000</tt> and the method <tt>allNamesShorterThan4</tt>.</p></li> <li><p>Design the class <tt>GivenKind</tt> that implements the<tt>ISelectImageFile</tt> interface with a method that produces<tt>true</tt> for all <tt>ImageFile</tt>s that are of the given<tt>kind</tt>. The desired <tt>kind</tt> is given as a parameter tothe constructor, and so is specified when a new instance of the class<tt>GivenKind</tt> is created.</p> <p><em>Hint:</em> Add a field to represent the desired <tt>kind</tt>to the class <tt>GivenKind</tt>.</p></li> <li><p>In the <tt>ExamplesImageFile</tt> class use the method<tt>allSuch</tt> and the class <tt>GivenKind</tt> to determine whetherall files in a list are <em>jpg</em> files. This should be written asa test case for the method <tt>allSuchImageFile</tt>.</p>  <p>Do it again, but now ask about the <em>gif</em> files.</p></li><li><p>If you have some time left, design the method<tt>filterImageFile</tt> that produces a list of all<tt>ImageFile</tt>s that satisfy the <tt>ISelectImageFile</tt>predicate. Test it with as many of your predicates as youcan.</p></li> <li><p>Follow the same steps as above to design the method<tt>anySuchImageFile</tt>  that that determines whether there is anitem a list that satisfies the predicate defined by the<tt>select</tt> method of a given instance of the type<tt>ISelectImageFile</tt>.</p></li> <li><p>Finish the work at home and save it in your portfolio.</p></li></ol><p><em>Food for thought</em>: Think how this program would bedifferent if we have instead worked with lists of <tt>Book</tt>s, orlists of <tt>Shape</tt>s.</p> <hr></hr><!--Comment: ...--> <address></address><!-- hhmts start -->Last modified: Mon Feb 13 16:05:26 EST 2012 <!-- hhmts end --></body> </html>  </body></html>