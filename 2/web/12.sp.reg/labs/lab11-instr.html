<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from lab11.tex by tex2page, v 20070609
(running on Racket 5.2, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
lab11
</title>
<link rel="stylesheet" type="text/css" href="lab11-Z-S.css" title=default>
<meta name="robots" content="index,follow">
</head>
<body>
<div id=slidecontent>
<div align=right class=navigation></div>
<p></p>
<p>
</p>
<p>





</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>

</p>
<p>
</p>
<p>
&copy;2012 Felleisen, Proulx, et. al.</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>



</p>
<p>
</p>
<a name="node_sec_11"></a>
<h1 class=section>11&nbsp;&nbsp;Working with HashMap: Overriding &#8217;equals&#8217;</h1>
<p>The goal of this lab is to learn to use the professional test harness
JUnit. It is completely separated from the application code. It is designed
to report not only the cases when the result of the test differs from
the expected value, but also to report any exceptions the program
would throw. The slight disadvantage is that it uses the Java
<tt>equals</tt> method that by default only checks for the
instance identity. To use the JUnit for the method tests similar to
those we have done before we need to <em>override</em> the
<tt>equals</tt> any time we wish to compare two instances of a
class in a manner different from the strict instance identity.</p>
<p>
However, each time we override the <tt>equals</tt> method we should
make sure that the <tt>hashCode</tt> method is changed in a compatible
way. That means that if two instances are <tt>equal</tt> under our
definition of <tt>equals</tt> then the <tt>hashCode</tt> method for
both instances must produce the same value.</p>
<p>
We start with learning to use <tt>HashMap</tt> class. We then see how
we can override the needed <tt>hashCode</tt> method. Finally, we also
override the <tt>equals</tt> method to implement the equality
comparison that best suits our problem.</p>
<p>
</p>
<a name="node_sec_Temp_1"></a>
<h2 class=section>Part 1: Using the HashMap</h2>
<p>Our goal is to design a program that would show us on a map the
locations of the capitals of all 48 contiguous US states and show us
how we can travel from any capital to another. </p>
<p>
This problem can be abstracted to finding a path in a network of nodes
connected with links &#8212; known in the combinatorial mathematics as a
graph traversal problem. You have already seen this problem in your
assignments at least once.  </p>
<p>
</p>
<a name="node_sec_Temp_2"></a>
<h3 class=section>The Data</h3>
<p>To provide real examples of data the provided code includes the
(incomplete) definitions of the class <tt>City</tt> and the class
<tt>State</tt>. </p>
<p>
</p>
<ol>
<li><p>Download the code for <strong>Lab 11</strong> and build the project
<strong>USmap</strong>.   </p>
<p>
</p>
<li><p>Download the file of state capitals <em>caps.txt</em>. </p>
<p>
</p>
<li><p>The project contains an implementations of the <tt>Traversal</tt>
interface by the class <tt>InFileCityTraversal</tt> that allows 
you to read a file of <tt>City</tt> data. The code in the
<tt>Examples</tt> class saves the city data generated by the
<tt>InFileCityTraversal</tt> into an <tt>ArrayList</tt>. </p>
<p>
Run the code with some of the city data files.</p>
<p>
</p>
<li><p>The <tt>Examples</tt> class contains examples of the data
for three New England states (ME, VT, MA) and their
capitals. Add the data for the remaining three states: CT, NH,
RI. Initialize the lists of neighboring states for each of 
these states. Do not include the neighbors outside of the New
England region.</p>
<p>
</p>
<li><p>Finally, look at the definition of the method <tt>toString</tt>
both in the <tt>City</tt> class and in the <tt>State</tt> class. The
class <tt>Object</tt> defines such method for all classes, but it is
of little use. Comment out the <tt>toString</tt> method in the class
<tt>City</tt> and see what happens when you run the code.</p>
<p>
From now on, you should define a <tt>toString</tt> method for every
class you define, making sure the resulting <tt>String</tt> is
readable and the fields are clearly identifiable.</p>
<p>
</p>
</ol><p></p>
<p>
We now have all the data we need to proceed with learning about hash
codes, equals, and <tt>JUnit</tt>.</p>
<p>
</p>
<a name="node_sec_Temp_3"></a>
<h3 class=section>Using HashMap</h3>
<p>The class <tt>USmap</tt> contains only one field and a constructor. The
field is defined as:</p>
<p>
<span class=footnotesize></p>
<pre class=verbatim>HashMap&lt;City, State&gt; states = new HashMap&lt;City, State&gt;();
</pre><p>
</p>
<p>
The <tt>HashMap</tt> is designed to store the values of the type
<tt>State</tt>, each corresponding to a unique key, an instance of a
<tt>City</tt> &#8212; its capital.</p>
<p>
<em>Note: In reality this would not be a good choice to the keys for
a HashMap &#8212; we do it to illustrate the problems that may come up.</em></p>
<p>
</p>
<ol><p>
</p>
<li><p>Go to Java documentation and read what is says about
<tt>HashMap</tt>. The two methods you will use the most are <tt>put</tt> and
<tt>get</tt>. </p>
<p>
</p>
<li><p>Define the method <tt>initMap</tt> in the class
<tt>Examples</tt> that will add to the given <tt>HashMap</tt> the six New
England states.</p>
<p>
</p>
<li><p>Test the effects by verifying the size of the <tt>HashMap</tt>
and by checking that it contains at least three of the items you
have added. Consult <em>Javadocs</em> to find the methods that allow you to
inspect the contents and the size of the <tt>HashMap</tt>.</p>
<p>
</p>
</ol><p></p>
<p>
</p>
<a name="node_sec_Temp_4"></a>
<h3 class=section>Understanding HashMap</h3>
<p>We will now experiment with <tt>HashMap</tt> to understand how changes in the
<tt>equals</tt> method and the <tt>hashCode</tt> method affect its
behavior. </p>
<p>
</p>
<ol><p>
</p>
<li><p>Define a new <tt>City</tt> instance <tt>boston2</tt> initialized
with the 
same values as the original <tt>boston</tt>. Now put the state
<tt>MA</tt> again into the table, using <tt>boston2</tt> as the
key. The size of the <tt>HashMap</tt> should now be 7.</p>
<p>
</p>
<li><p>Now define the <tt>equals</tt> method in the class <tt>City</tt>
that makes sure the two cities have the same name, state, zip code,
and the same latitude and longitude. Use the given helper method
<tt>sameDouble</tt> to compare the last two fields. Start the method
with:</p>
<p>
<span class=footnotesize></p>
<pre class=verbatim>public boolean equals(Object obj){
  City temp = (City)obj;  ...
</pre><p>
</p>
<p>
If the given object is of the type that cannot be cast to
<tt>City</tt> the method will fail at runtime with the
<tt>ClassCastException</tt>.</p>
<p>
Now run the same experiment as above. The resulting <tt>HashMap</tt>
still has size seven. Even though we think the two cities are equal,
they produce a different hash code.</p>
<p>
</p>
<li><p>Now hide the <tt>equals</tt> method (comment it out) and define
a new <tt>hashCode</tt> method by producing an integer that is the
sum of the hash codes of all the fields in the <tt>City</tt> class.</p>
<p>
Now run the same experiment as above. The resulting <tt>HashMap</tt>
still has size seven. Even though the two cities produce the same hash
code, the <tt>HashMap</tt> sees that they are not <tt>equal</tt> and
does not confuse the two values.</p>
<p>
</p>
<li><p>Now un-hide the <tt>equals</tt> method so that two <tt>City</tt>
objects that we consider to be the same produce the same hash code. </p>
<p>
When you run the experiment again you will see that the size of the
<tt>HashMap</tt> remains the same after we inserted Massachusetts with
the <tt>boston2</tt> key.</p>
<p>
<em>Note: Read in &quot;Effective Java&quot; a detailed tutorial on overriding
equals and hashCode.</em></p>
<p>
</p>
</ol><p></span></p>
<p>
</p>
<a name="node_sec_Temp_5"></a>
<h2 class=section>Part 2: Introducing JUnit</h2>
<p>You will now rewrite all your tests using the <tt>JUnit4</tt>. In the
<strong>File</strong> menu select <strong>New</strong> then <strong>JUnitTestCase</strong>. The
tests for each of the methods will then become one test case similar
to this one: </p>
<p>
<span class=footnotesize></p>
<pre class=verbatim>/**
 * Testing the method toString
 */
public void testToString(){
    assertEquals(&quot;Hello: 1\n&quot;, this.hello1.toString());
    assertEquals(&quot;Hello: 3\n&quot;, this.hello3.toString());
}
</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
<p>
We see that <tt>assertEquals</tt> calls are basically the same as the
test methods for 
our test harnesses, they just don&#8217;t include the names of the tests. Try
to see what happens when some of the tests fail, when a test throws an
exception, and finally, make sure that at the end all tests succeed.</p>
<p>
</p>
<ul>
<li><p>Add a method that determines whether the city is South of the
given latitude. Run the tests using the JUnit.</p>
<p>
</p>
<li><p>Add a method that determines whether this city is in the same
state as the given city. Run the tests using the JUnit.
</p>
</ul><p> </p>
<p>
<em>Ask for help, try things &#8212; make sure you can use JUnit, so you
will not run into problems when working on the assignment and the
final project.</em></p>
<p>
</p>
<a name="node_sec_Temp_6"></a>
<h2 class=section>toString</h2>
<p>Until now you could see the values of your objects, because the
<i>tester</i> library printed the values of all fields in a
humanly-readable form. If you want to be able to see the values of
your data without the help of the <i>tester</i>, you need to
implement a method that produces a <i>String</i> that represents the
values of the relevant fields. Every class already comes with such
method: the method <tt>toString()</tt> in the class <tt>Object</tt>,
but it only prints the name of the class where the object has been
defined, with some confusing number appended. Try to see what you get
for some simple class.</p>
<p>
To get meaningful results and to be able to see the values of objects,
programmers override the <i>toString</i> method. In the class
<tt>City</tt> this may be done as follows:</p>
<p>
<span class=footnotesize></p>
<pre class=verbatim>/** Represent  city data as a String for printed display */
public String toString(){
  return (&quot;new &quot; + getClass() + &quot;(&quot; + 
      City.zipFormat.format(this.zip)   + &quot;,   &quot; + 
      this.name  + &quot;,  &quot; + 
      this.state + &quot;, &quot; + 
      this.longitude + &quot;, &quot; + 
      this.latitude + &quot;)\n&quot;);
}
</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
<p>
Can you think of how you would implement the <tt>toString</tt> method
for the class <tt>USmap</tt>. Try to do it.</p>
<p>
</p>
<a name="node_sec_Temp_7"></a>
<h2 class=section>Warning</h2>
<p>Try to get as much as possible during the lab. Ask questions when you
do not understand something. </p>
<p>
</p>
<a name="node_sec_Temp_8"></a>
<h2 class=section>Stack, Queue, Priority Queue, LinkedList; Vector</h2>
<p>Look up the documentation for the following Java classes and
interfaces: <tt>Stack, Queue, PriorityQueue, List, LinkedList</tt> and
<tt>Vector</tt>. Identify which of them represent interfaces, which
represent abstract classes, and which provide a complete
implementation that you can use in your program. Draw a class diagram
that shows the relationship between these classes and interfaces.</p>
<p>
</span></span></span></p>
<div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">
<div align=right class=navigation></div>
</p>
<p></p>
<div align=right class=colophon>Last modified: Monday, March 26th, 2012 9:56:52am<br><div align=right class=advertisement>HTML conversion by <a href="http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html">TeX2page 20070609</a></div></div>
</div>
</body>
</html>
