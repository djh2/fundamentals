\documentclass[11pt]{article}

%% ------------------------------------------------------------------
%% SOLUTIONS:
\def\thel{\noindent\rule{2.5cm}{.5pt}}
\long\def\begsol#1 #2\endsol{#1}
\def\begsol#1{\thel {\bf Solution} \thel}\def\endsol{\relax}
%%uncomment the above line to get the solutions printed

\newcommand\code[1]{\texttt{#1}}
\newcommand\bcode[1]{\texttt{\textbf{#1}}}

%% PROBLEMS:
\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
\newcounter{Pctr}
\newenvironment{problem}{\stepcounter{Pctr}%
\begin{description}
\item[\noindent{\bf Problem} \arabic{Pctr}] 
\end{description}}{\relax}
%% ------------------------------------------------------------------

%% SUBPARTS:
\newcounter{parts}
\renewcommand{\theparts}{\Alph}
%% ------------------------------------------------------------------

\begin{document}

\renewcommand{\theenumi}{\Alph{enumi}}
\setcounter{Pctr}{0}

%% ------------------------------------------------------------------

\vfill
\centerline{\Large CS 2510 Exam 2 -- Spring 2012}

~\\[2cm]

\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{200pt}{.1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{200pt}{.1pt} \\[.5cm]
\end{tabular}
\end{center}

\noindent\begin{minipage}{7.5cm} $\bullet$ Write down the answers in the
space provided. 

$\bullet$ You may use all syntax that you know from \textit{FunJava}
(that is, the parts of Java we have studied in class), although there
are several features you will \emph{not} need.

$\bullet$ When defining methods, you do not need to give a complete
class definition---just indicate in which class your method definition
should be placed.

$\bullet$ For tests you only need to provide the expression that
computes the actual value, connecting it with an arrow to the expected
value. For example \code{s.method() -> true} is sufficient.

$\bullet$ Remember that the phrase ``design a class'' or ``design a
method'' means more than just providing a definition. It means to
design them according to the \textbf{design recipe}.  You are
\textit{not} required to provide a method template unless the problem
specifically asks for one.  However, be prepared to struggle if you
choose to skip the template step.

$\bullet$ We will not answer \textit{any} questions during the exam.

\bigskip

\textit{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{4.5cm}
\begin{tabular}{|c|l|@/r|}
\hline
\textbf{Problem} & Points & \\ \hline
A & & 5\\ \hline
B & & 5\\ \hline
C & & 10\\ \hline
D & & 10\\ \hline
\textbf{Total} &  & 30 \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

%% -----------------------------------------------------------------------------
%% 
\pts{34}
\begin{problem}

The Boston power grid consists of a network of connected electric
transformers (like the one that burst into flames last night).  There
are three basic kinds of transformers: those that simply transmit
power to another transformer, those that split electricity to two
other transformers, and those that are the end points of the power
network that don't connect to any further transformers.  When a power
grid is set up, it's done in such a way that no power is transmitted
from any transformer back to itself (there are no cycles in the grid);
cycles cause fires.  Transformers also carry some data to help
identify each point in the grid.

The following class diagram represent power grids:

\begin{verbatim}
                     +--------------+<-------------------------+
                     |    Trans<T>  |<-----------------------+ |
                     +--------------+<---------------------+ | |
                     | T data       |                      | | |
                     +--------------+                      | | |
                     / \   / \   / \                       | | |
                     ---   ---   ---                       | | |
                      |     |     |                        | | |
        +-------------+     |     +-----------+            | | |
        |                   |                 |            | | |
        |                   |                 |            | | |
 +-------------+      +---------------+  +--------------+  | | |
 |   End<T>    |      | Link<T>       |  | Couple<T>    |  | | |
 +-------------+      +---------------+  +--------------+  | | |
                   +--| Trans<T> conn |  | Trans<T> one |--+ | |
                   |  +---------------+  | Trans<T> two |----+ |
                   |                    +---------------+      |
                   +-------------------------------------------+
\end{verbatim}


\begin{enumerate}


\newpage
%-----------------------------------------------
\item {\em{(5 points)}}

Here is a graphical view of a local power grid:

\begin{verbatim}
             "BOS"
            /     \
           /       \
       "Logan"     "BPD"
       /    \       |
 "Seaport" "ICA"   "MFA"
       \    /  \    | 
      "Ferry"   "NEU"
                 |
              "Ruggles"
\end{verbatim}

When a transformer appears above another with a line between them, it
means the upper transformer transmits power to the lower one.  The
strings given show the data each transformer carries.

Translate the above information into examples of data that represent
the grid.

\begsol{\vspace{0.5in}}
\begin{verbatim}
Trans<String> r = new End<String>("Ruggles");
Trans<String> n = new Link<String>("NEU", r);
Trans<String> m = new Link<String>("MFA", n);
Trans<String> f = new End<String>("Ferry");
Trans<String> i = new Couple<String>("ICA", f, n);
Trans<String> s = new Link<String>("Seaport", f);
Trans<String> l = new Couple<String>("Logan", s, i);
Trans<String> p = new Link<String>("BPD", m);
Trans<String> b = new Couple<String>("BOS", l, p);
\end{verbatim}
\endsol

\newpage
\item  {\em{(5 points)}}

Here is the data representation of another grid:

\begin{verbatim}
Node<String> t1 = new Terminal<String>("h");
Node<String> t2 = new Terminal<String>("b");
Node<String> t3 = new Split<String>("a", t1, t2);
Node<String> t4 = new Terminal<String>("z");
Node<String> t5 = new Split<String>("c", t4, t3);
Node<String> t6 = new Repeat<String>("j", t3);
Node<String> t7 = new Repeat<String>("d", t6);
Node<String> t8 = new Split<String>("g", t5, t7);
Node<String> t9 = new Terminal<String>("t");
Node<String> t10 = new Split<String>("s", t9, t5);
Node<String> t11 = new Split<String>("k", t10, t8);
\end{verbatim}

Translate the above into a graphical representation of the grid
similar to that given in part A.

\begsol{\vspace{0.5in}}
\begin{verbatim}
     "k"
    /   \
   /    "g"
  /    /   \
 "s"   |   "d"     
 |  \  /    |     
"t" "c"   "j"  
     / \  /
  "z"   "a" 
       /  \
     "h"  "b"
\end{verbatim}
\endsol


\newpage
%-----------------------------------------------
\item {\em{(10 points)}}

One measure of the power grids robustness is the number of paths 
between two transformers.

Design the method {\tt countPaths} that computes the number of paths
from this transformer to a tranformer containing the given data.

\begsol{\vspace{0.5in}}

\begin{verbatim}
// in Trans<T>:
// Count the number of paths from this transformer to one containing 
// the given data
abstract public int countPaths(T data);

// in End<T>:
public int countPaths(T data) {
  if (this.data.equals(data)
    return 1;
  else 
    return 0;
}

// in Link<T>
public int countPaths(T data) {
  if (this.data.equals(data)
    return 1;
  else 
    return this.conn.countPaths(data);
}

// in Couple<T>
public int countPaths(T data) {
  if (this.data.equals(data))
    return 1;
  else
    return this.one.countPaths(data) + this.two.countPaths(data)
}
r.countPaths("Ruggles") -> 1
r.countPaths("NEU") -> 0
n.countPaths("Ruggles") -> 1
b.countPaths("Ruggles") -> 2
\end{verbatim}
\endsol

\newpage
%-----------------------------------------------
\item {\em{(10 points)}}

The efficiency of a power grid can be determined by the longest path
that power is transfered on.

Design the method {\tt maxLength} that finds the length of the longest
connection from this node to any end transformer.

\begsol{\vspace{0.5in}}
\begin{verbatim}
// in Trans<T>:
// Compute the length of the longest path power can travel on.
abstract int countPaths(T data);

// in End<T>:
public int maxLength() {
  return 1;  // or 0.
}

// in Link<T>
public int maxLength(T data) {
  return 1 + this.conn.maxLength();
}

// in Couple<T>
public int countPaths(T data) {
  return 1 + Math.max(this.one.maxLength(), this.two.maxLength());
}

r.maxLength() -> 1
b.maxLength() -> 4
\end{verbatim}
\endsol

\newpage
%-----------------------------------------------
\end{enumerate}
\end{problem}
\end{document}

