<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>CS 2510 Spring 2012: Assignment 9 - Direct Access Data Structures</title>
</head>


<h3>copyright 2012 Felleisen, Proulx, et. al.</h3>

<body>
<h1>CS 2510 Spring 2012:Assignment  9 - Direct Access Data Structures</h1>


<h4>Practice Problems</h4>

<p>Work out the following exercise. Do not add it
to your assignment submission, though you should keep it in your
electronic portfolio in your own <em>svn</em> repository.</p> 

<p><strong>Problem: Using ArrayList</strong></p>

<p>For this part of the assignment download the <a
href="Balloons.zip">Balloons.zip</a>, which contains the following
files:</p> 

<ul>

<li><tt>Balloon.java</tt>: a sample data class representing
  Balloons.</li>

<li><tt>TopThree.java</tt> will be used to practice working with
  <tt>ArrayList</tt> in imperative style (using mutation).</li>

<li><tt>Examples.java</tt> file that defines examples of all
  data and defines all tests.</li>
</ul>

<p>Create a new <strong>Project</strong> <em>HW9-Balloons</em> and import these
files.  Don't forget to add the <em>tester</em> library too.  In this
part of the lab we will work with <tt>ArrayList</tt>s of
</tt>Balloons</tt>.</p>

<ol>

<li><p>The class <tt>TopThree</tt> now stores the values of the three
  elements in an <tt>ArrayList</tt>. Complete the definition of the
  <tt>reorder</tt> method. Have a close look at the documentation for
  the <tt>ArrayList</tt> and <tt>Comparator</tt> to decide which methods
  you should use.</p></li>

<li><p>In the <tt>Examples</tt> class, design the method
  <tt>isSmallerThanIndex</tt> that determines whether the radius of the
  <tt>Balloon</tt> at the given position (index) in the given
  <tt>ArrayList</tt> of <tt>Balloon</tt>s is smaller than the given
  <tt>limit</tt>.</p></li>

<li><p>Design the method <tt>isSameAsIndex</tt> that determines whether
  the balloon at the given position in the given <tt>ArrayList</tt> of
  <tt>Balloon</tt>s has the same <tt>size</tt> and <tt>location</tt> as the
  given <tt>Balloon</tt>.</p></li>

<li><p>Design the method <tt>inflateAtIndex</tt> that increases the
  radius of a <tt>Balloon</tt> at the given index by 5. For this you
  should also design a helper method... where do you think it should
  be?</p></li>

<li><p>Design the method <tt>swapAtIndices</tt> that swaps the elements
  of the given <tt>ArrayList</tt> at the two given positions (indices).
  Make sure that this method works for any <tt>ArrayList</tt>... it
  should be parametrized.</p></li>

</ol>

<p><em>Note 1:</em> We have used the words <em>position</em> in the
<tt>ArrayList</tt> and <em>index</em> in the <tt>ArrayList</tt>
interchangeably. Both are commonly used, so we want to make sure you
are comfortable with to both ways of describing locations of elements
in an <tt>ArrayList</tt>.</p>

<p><em>Note 2:</em> Of course, the tests for these methods will also
appear in the <tt>Examples</tt> class. Make sure that every test can be
run independently of all other tests. To do this, you must initialize
(<tt>reset</tt>) the data at the beginning of your test method, then
evaluate the test by invoking the appropriate <tt>check</tt> method.
Just to be safe, you may also reset the data after the tests are
complete.</p>

<hr></hr>

<h4>Pair Programming Assignment</h4>

<p>These problems should be checked into your pair's SVN repository
by the due date.</p>

<p><strong>Project naming requirements</strong></p>
<p>The names of the projects and some of the project files must be
exactly the same as specified in the assignment. Failure to do so
makes it impossible for the graders to run your submission and results
in immediate <strong>loss of at least 50%</strong> of the homework
credit.</p>

<p>Every file you submit must have a header that identifies you and
the problem it solves. So, for the first problem the header should
look like this:</p>

<pre>
// Assignment 9 Problem 1
// Partner Name1
// partner1username
// Partner Name2
// partner2username
// 20 March 2012
</pre>


<h3>Problem 1 Binary Search</h3>

<p>Create a project with the name <tt>HW09Problem1</tt>.</p>

<p>Finish the <strong>Binary search</strong> problem from Lab 9.</p>

<p>Include examples of <code>ArrayList</code>s with data of the type
<code>Integer</code> and the type <code>Person</code> (where we know
person's name and age). For the type <code>Person</code> order the
persons by their names (lexicographically). You do not need to include
examples of the <code>ArrayList</code>s with data of the type
<code>String</code> as was specified in the lab.</p>

<hr></hr>


<h3>Problem 2 Abstract Data Types</h3>

<p>Create a project with the name <tt>HW09Problem2</tt>.</p>

Your library includes the file <em>DataSet.java</em> that defines the
following interface:

<pre>

/**
 * An interface that represents a data set
 * where we can add and remove items
 *
 * @param <T> the type of data items in this data set
 */
interface DataSet<T>{

  /**
   * Add the given item to this data set
   * 
   * @param t the given data item
   */
  public void add(T t);

  /**
   * EFFECT: remove an item from this data set
   * 
   * @return the item that has been removed
   * @throws a RuntimeException if this data set is empty
   */
  public T remove();

  /**
   * Produce the number of items in this queue
   * @return the the number of items in this data set
   */
  public int size();
  
  /**
   * Produce the 'next to be removed' item in this data set
   * @return the desired item
   */
  public T current();
}
</pre>

<p>Design three different implementations of this interface as
shown. Next week we will use these data structures to design a card
game.</p> 

<ol>
  
<li><p>Design the class <tt>Stack</tt> that implements the
  <tt>DataSet</tt> interface using an <tt>ArrayList</tt> to hold the
  data items and adds and removes the items at the same end.</p>

  <p>The class should contain an <tt>ArrayList</tt> as one of its
  fields. You may add other fields that will help you in implementing
  the interface.</p>

<p>This data structure is also known as LIFO - <strong>L</strong>ast
  <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut
  organization.</p></li>  

<li><p>Design the class <tt>Queue</tt> that implements the
  <tt>DataSet</tt> interface using an <tt>ArrayList</tt> to hold the
  data items and adds the data items at one end and removes the items
  from the other end.</p> 


<p>This data structure is also known as FIFO - <strong>F</strong>irst
  <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut
  organization.</p></li>  

<li><p>Design the class <tt>QueueList</tt> that implements the
  <tt>DataSet</tt> interface using an <em>Linked List</em> to hold the
  data items and adds the data items at one end (the tail of the
  queue) and removes the items from the other end (the head of the
  queue). <em>Just like in a grocery store - you get in at the tail
  end of the queue, and when you are at the head of the queue, it is
  your turn, you get to pay, and leave the queue.</em></p>

  <p>The class diagram for this data structure would be:</p>

<pre>           
         +-----------+
         | Node      |
         +-----------+
         | Data data |
         | Node next |
         +-----------+
              / \
              ---
               |
  ----------------------------
  |                          |
  |      +------------+      |
  |      | Qlist      |      |
  |      +------------+      |
  |  +---| Head front |      |
  |  |   | Tail tail  |---+  |
  |  |   | int count  |   |  |
  |  |   +------------+   |  |
  |  |                    |  |
  |  v                    v  |
+------------+       +-----------+
| Head       |       | Tail      |
+------------+       +-----------+
+------------+       +-----------+
</pre>

  <p>The <em>head</em> node has no data (the value of
  <code>data</code> is <code>null</code>). If the list is empty, the
  <code>next</code> node is the <em>tail</em>.<p>

  <p>The <em>tail</em> node has no data (the value of
  <code>data</code> is <code>null</code>). The <em>tail</em> has the
  job of remembering where is the last 
  node that has been inserted into the queue, so we can add another
  node after the last node when the next <em>add</em> request comes. If
  the list is empty, the <code>next</code> node of the <em>tail</em>
  is the <em>head</em> node.</p>

  <p>The following drawing shows the list-based queue with three nodes:</p>

<pre>
            +--------------+      
            | Qlist        |      
            +--------------+      
        +---| front = head |      
        |   | tail = tail  |---------------------------------------------------+
        |   | count = 3    |                                                   |
        |   +--------------+                                                   |
        |                                                    +-----------------|----+
        |       +--------+      +--------+      +--------+   |    +--------+   |    |
        |       |        |      |        |      |        |   |    |        |   |    |
 head   v       |  n1    v      |  n2   v       |  n3    v   v    |  tail  v   v    |
+-------------+ | +-----------+ | +-----------+ | +-------------+ | +-------------+ |
| Head        | | | Node      | | | Node      | | | Node        | | | Tail        | |
+-------------+ | +-----------+ | +-----------+ | +-------------+ | +-------------+ |
| data = null | | | data = 7  | | | data = 4  | | | data = 9    | | | data = null | |
| next = n1   |-+ | next = n2 |-+ | next = n3 |-+ | next = tail |-+ | next = n3   |-+
+-------------+   +-----------+   +-----------+   +-------------+   +-------------+
</pre>

  
</li>  

</ol>


<hr></hr>
<address></address>
<!-- hhmts start -->Last modified: Wed Mar 14 11:59:56 EDT 2012 <!-- hhmts end -->
</body> </html>
