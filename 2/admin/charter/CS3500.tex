\documentclass[11pt]{article}

\usepackage{fullpage}

\title{CS~3500 Course Charter \& Syllabus}

\author{Jay Aslam, Will Clinger, David Van Horn \\
        College of Computer and Information Science \\
        Northeastern University}
        
\date{February 21, 2012}

\begin{document}

\maketitle

\section{CS~3500 Course Charter}

\paragraph{Course Title:}
%
CS~3500 \emph{Object-Oriented Design} (4 SH)

\paragraph{Current Catalog Description:}
%
Presents a comparative approach to object-oriented programming
and design. Discusses the concepts of object, class, meta-class,
message, method, inheritance, and genericity. Reviews forms of
polymorphism in object-oriented languages. Contrasts the use of
inheritance and composition as dual techniques for software reuse:
forwarding vs. delegation and subclassing vs. subtyping. Fosters
a deeper understanding of the principles of object-oriented
programming and design including software components,
object-oriented design patterns, and the use of graphical design
notations such as UML (unified modeling language). Basic concepts
in object-oriented design are illustrated with case studies in
application frameworks and by writing programs in one or more
object-oriented languages.

\paragraph{Course Description As Stated In Obsolete Course Charter:}
%
Presents a comparative approach to object-oriented
programming and design, with an emphasis on techniques for programming
large-scale systems. Discusses the concepts of object, class,
meta-class, message, method, inheritance, and genericity. Reviews
forms of polymorphism in object-oriented languages. Contrasts the use
of inheritance and composition as dual techniques for software reuse:
forwarding versus delegation and sub-classing versus
sub-typing. Studies main programming language tools and techniques to 
facilitate the creation of applications: modularity, encapsulation,
code reuse techniques, design patterns. Basic concepts in
object-oriented design are illustrated by writing programs in one or
more object-oriented languages. 

\paragraph{Course Description As Stated in Online Course Charter:}
%
The course presents the theory and practice of object-oriented
programming. The course enhances students understanding of the
concepts of object, class, message, method, inheritance, and
genericity. The course covers a basic model for objects; the
principles of types and polymorphism in object-oriented programming
languages; different forms of abstraction; and theory and practice
of reuse. The course also introduces students to some
object-oriented design patterns that practitioners have found useful. 

\paragraph{Proposed Course Description:}
%
Presents the theory and practice of object-oriented programming,
emphasizing abstractions and ideas that scale to large systems.
Introduces representation independence and related concepts such as
information hiding, encapsulation, modularity, and interchangeability
of parts.  Analyzes strengths and weaknesses of alternative
representations by considering asymptotic efficiency for the best,
worst, average, and amortized case.  Illustrates general paradigms
such as divide-and-conquer algorithms, precomputation, caching,
memoization, and dynamic programming.  Covers static types and
explains how subtyping and several forms of polymorphism
(parametric, ad hoc, and inclusion) support design patterns that
contribute to reuse and extensibility.

\paragraph{Prerequisites:}
%
CS~2510. 

\paragraph{Textbooks:}
%
\noindent
Barbara Liskov and John Guttag.
\emph{Program Development in Java: Abstraction, Specification,
and Object-Oriented Design}.
Addison-Wesley, 2001.

\noindent
Peter Sestoft.  \emph{Java Precisely}, Second Edition.
MIT Press, 2005.


\paragraph{Topics Covered:}
%
Object-oriented programming:
%
classes and inheritance,
dynamic method dispatch,
class diagrams for inheritance and composition,
abstract classes and protocols (e.g. Java interfaces),
overriding versus overloading,
immutable versus mutable,
organized approaches to designing objects and classes,
refactoring.
%
Abstraction: 
%
the abstraction barrier,
client perspective versus implementor perspective,
specifications as contracts,
black-box testing against specifications,
substitutability of implementations,
representation independence,
information hiding,
encapsulation,
tradeoffs between information hiding, encapsulation, and reuse.
%
Algorithmic thinking:
%
asymptotic notation,
worst case, best case, average case,
amortized efficiency,
divide-and-conquer algorithms,
precomputation,
caching,
memoization and/or dynamic programming.
%
Static types:
%
compile-time versus run-time,
interactions with reuse,
subtyping,
ad hoc (sum) polymorphism, 
inclusion (product) polymorphism,
parametric polymorphism.
%
Basic design patterns:
%
Factory Method,
Singleton,
Wrapper/Adapter,
Composite,
Iterator,
Functional Visitor.

\paragraph{Course Outcomes:}
%
Upon completion of this course, a student should be able to: 
%
\begin{enumerate}
\item
List and describe fundamental mechanisms of object-oriented
programming, including inheritance, subtyping, polymorphism,
and dynamic method dispatch.
\item
Use at least one object-oriented programming language well
enough to implement abstract data types.
\item
Evaluate implementations of abstract data types with respect
to correctness, abstraction, efficiency, and code reuse.
%\item
%Transfer his or her programming knowledge to other OO languages and
%other programming paradigms.
\end{enumerate}


\paragraph{Measurement of Course Outcomes:}
%
Outcomes are measured and verified through: (1) regular programming
homeworks (five to ten recommended), which may combine to develop
a larger piece of software by the end of the semester; (2) two to four
major exams; (3) inclusion of student's work in an electronic portfolio.

\section{CS~3500 Sample Syllabus}

The theme of the course is representation independence and
its contribution to algorithmic creativity.

That theme presents a clean break from Fundies 2, in which
students are taught how to write code that mirrors the
structure of their data.  The representation-dependent
approach taken in Fundies 2 is appropriate for implementors
of an abstract data type, but is inappropriate for the ADT's
clients.

CS 3500 introduces the abstraction barrier that separates
clients from implementors.  Implementors must know how values
of an ADT are representated, but clients should not.  Making
client code independent of the representation makes it possible
for implementors to change representations without breaking
client code.  Representation independence allows implementors
to replace naive implementations by implementations that use
more sophisticated representations and algorithms.

CS 3500 should be taught using a programming langauge that
provides adequate support for class-based inheritance and for
information hiding.  Although Java has been used to teach most
sections of CS 3500, mainly because students are taught Java in
Fundies 2, some instructors have taught CS 3500 using Smalltalk
or Scala.  For concreteness, the sample syllabus below will
assume the language is Java.



\paragraph{MODULE 1:}
%
ADTs and Representation Independence (3 weeks)
%
\begin{itemize}
\item the abstraction barrier
\item ADTs, signatures, specifications
\item algebraic specifications of immutable ADTs
\item the Factory Method pattern hides representations from clients
\item UML class diagrams
\item the recipe representation
\item translation of algebraic specifications into idiomatic OO code
\item help clients out by throwing exceptions for unspecified cases
\item axiomatic specifications of equals(Object) and hashCode()
      may hide some representation details
\item substitution principle:
      all implementations that satisfy the specification are interchangeable
\item black-box testing against specification
\end{itemize}

\paragraph{MODULE 2:}
%
Taking Advantage of Representation Independence (4 weeks)
%
\begin{itemize}
\item parametric polymorphism
\item asymptotic notation (big-O, Omega, Theta)
\item best, average, and worst case
\item general rules for improving performance
\begin{itemize}
\item Don't.
\item Don't yet.
\item Don't optimize any more than necessary.
\end{itemize}
\item general paradigms of algorithm design
\begin{itemize}
\item Don't compute things you don't need to compute.
\item Don't recompute things you can avoid recomputing.
\begin{itemize}
\item divide and conquer
\item precomputation
\item caching
\item memoization and/or dynamic programming
\end{itemize}
\end{itemize}
\item refactoring transformations
\item invariants
\item more efficient representations
\end{itemize}

\paragraph{MODULE 3:}
%
Software Reuse (2 weeks)
%
\begin{itemize}
\item the Functional Visitor pattern
\item the Iterator pattern
\item mutable state versus concurrency
\item reuse by inheritance versus reuse by composition
\item protocols (which Java calls interfaces)
\item the fragile base class problem
\end{itemize}

\paragraph{MODULE 4:}
%
Static Types (2 weeks)
%
\begin{itemize}
\item safety properties and type errors
\item interaction with reuse
\item subtyping
\item sum and product types
\item ad hoc and inclusion polymorphism
\item bounded parametric polymorphism
\item covariant, contravariant, and monovariant type constructors
\end{itemize}

\end{document}
