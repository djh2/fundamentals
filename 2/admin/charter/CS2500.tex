\documentclass[11pt]{article}

\usepackage{fullpage}

\title{CS~2500: Course Charter \& Syllabus}

\author{Jay Aslam, Will Clinger, David Van Horn \\
        College of Computer and Information Science \\
        Northeastern University}
        
\date{February 21, 2012}

\begin{document}

\maketitle

\section{CS~2500 Course Charter}

\paragraph{Course Title:}
%
CS~2500 \emph{Fundamentals of Computer Science 1} (4 SH)

\paragraph{Course Description:}
%
Introduces the fundamentals of program design via study of increasingly
complex data definitions: structures, containment, unions, self-referential,
mutually referential. In addition, the course studies design via generative
recursion, accumulator-style functions, and mutation of variables and
structures. The course also introduces models of computations, which explain
what programs do when they are applied to inputs.

\paragraph{Prerequisites:}
%
The course requires no previous experience in writing computer programs, and
only assumes mathematics at the level of high-school Algebra. Students are
expected to have an interest in learning about Computer Science in depth.

\paragraph{Textbooks:}
%
\emph{How to Design Programs}, Felleisen, Flatt, Findler, and Krishnamurthi, 
MIT Press, 2000.

\paragraph{Topics Covered:}
%
Computers and the nature of computation. (Formal) models of computation.
Functions; function definitions. Conditional computation structures. Structure
definitions. Modeling information with data. The structure of data:
composite, containment, union, self-referential, mutually referential,
cyclically defined. Program design and design recipes: design based on the
structure of data. Extensional equality of structured data. (Automated) testing.
Accumulators. Designing abstractions. Generative recursion.

\paragraph{Course Outcomes:}
%
Upon completion of this course, a student should be able to \emph{design programs},
and, consequently, have some understanding of the fundamentals of computation.
In particular, the student should be able to: Complete data analysis and
definition for problems that require the use of composition, containment,
union, and self-reference. Design programs to solve problems that consume and
produce data structures based on composition, containment, union, and
self-reference. Design test suites for these programs and evaluate the
outcomes. Design simple abstractions and test the design. Reason about the
performance characteristics of programs in a basic way.

\paragraph{Measurement of Course Outcomes:}
%
Outcomes are measured and verified through: Weekly programming homeworks.
Daily short paper-and-pencil quizzes. Two to four major exams. Inclusion of
student's work in an electronic portfolio.

\pagebreak

\section{CS~2500 Sample Syllabus}

The course sequences through the following topics:
\begin{itemize}
\item overview, intro to simple arithmetic calculation
\item atomic \& compound data: 
  \begin{itemize}
    \item integers
    \item booleans \& conditional computation
    \item records
  \end{itemize}
\item representation: information vs. data
\item data-driven programming
\item testing
\item unions
\item self-referential unions 1---recursion
\item self-referential unions 2---list processing
\item designing larger programs: top-down design; iterative refinement
\item recursion in all forms: trees, s-expressions, forests
\item abstraction: interfaces and implementations
\item abstraction: parametric data definitions and contracts
\item notions of equality
\item local name scope; simple asymptotic complexity
\item abstracting control with higher-order functions
\item constructing higher-order functions with lambda
\item infinite data structures and computations
\item generative recursion: root finding, sorting
\item generative recursion: graphs \& search; accumulators
\item review and wrap up
\end{itemize}

\end{document}

