\documentclass[11pt]{article}

\usepackage{fullpage}

\title{Report from the CS3500 Committee}

\author{Jay Aslam, Will Clinger, David Van Horn\\
        College of Computer and Information Science \\
        Northeastern University}
        
\date{DRAFT: May 27, 2012}


\begin{document}

\maketitle

The committee was charged with reviewing the CS3500 (\emph{Object-oriented Design}) curriculum, with the end goal of revising CS3500 in such a way that
%
\begin{itemize}
\item it retains the best aspects of the current object-oriented design course,
\item it does not excessively and unnecessarily overlap with CS2510 (\emph{Fundamentals~2}), and
\item it contains substantially more algorithmic content.
\end{itemize}
%
Specific concerns included:
%
\begin{enumerate}
\item That CS2510 is teaching substantial amounts of object-oriented design.  Therefore, there is a concern that there is currently a fair amount of overlap between CS2510 and CS3500.
\item That students have reported that in co-op interviews they are asked about algorithms and data structures, but do not know how to answer these questions.
\item That CS3500 is serving, in part, as a review and consolidation course, due to the variability in how CS2510 is taught: Students entering CS3500 have mixed backgrounds in various programming topics, depending on the specific instance of CS2510 that they took, necessitating that CS3500 spend a fair amount of time bringing everyone up to speed.
\end{enumerate}

Given the above charge and specific concerns, the committee chose to review the three course introductory programming sequence (CS~2500 \emph{Fundamentals~1}, CS2510, and CS3500) in its entirety for content, redundancy, and the possible inclusion of algorithmic concepts.

Our committee began by (1) studying the extant course charters and sample syllabi for the three course programming sequence, noting differences with the courses as currently taught, (2) identifying redundancies and inconsistencies in the programming sequence as currently taught, and (3) identifying those object-oriented programming concepts that could reasonably be moved from CS3500 to CS2510.

The end result of eliminating inconsistencies and excessive redundancies, as well as moving a handful of programming concepts from CS3500 to CS2510 where natural and practicable, was to free up approximately three weeks of time within CS3500 that could be devoted to algorithmic concepts.  Upon conferring with Deans Finkelstein and Rasala, it was decided that this would be sufficient for the time being.

Two options were considered for adding algorithmic concepts to CS3500: (1) devoting a three week block to algorithms or (2) integrating algorithmic concepts throughout the course.  It was decided that, pedagogically, Option~(2) was preferable to Option~(1).  CS3500, as currently taught, already covers a number of topics in algorithms such as big-O notation and some advanced data structures (e.g., red-black trees), and there are natural opportunities to introduce other data structures and algorithmic concepts such as the divide-and-conquer, greedy, and dynamic programming paradigms.  These additional algorithmic concepts should be introduced and taught, where appropriate, within the course.

In what follows, we provide updated course charters and sample syllabi for CS2500, CS2510, and CS3500, reflecting our recommendations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% CS2500
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak

\section*{CS~2500 Course Charter}

\paragraph{Course Title:}
%
CS~2500 \emph{Fundamentals of Computer Science 1} (4 SH)

\paragraph{Course Description:}
%
Introduces the fundamentals of program design via study of increasingly
complex data definitions: structures, containment, unions, self-referential,
mutually referential. In addition, the course studies design via generative
recursion, accumulator-style functions, and mutation of variables and
structures. The course also introduces models of computations, which explain
what programs do when they are applied to inputs.

\paragraph{Prerequisites:}
%
The course requires no previous experience in writing computer programs, and
only assumes mathematics at the level of high-school Algebra. Students are
expected to have an interest in learning about Computer Science in depth.

\paragraph{Textbooks:}
%
\emph{How to Design Programs}, Felleisen, Flatt, Findler, and Krishnamurthi, 
MIT Press, 2000.

\paragraph{Topics Covered:}
%
Computers and the nature of computation. (Formal) models of computation.
Functions; function definitions. Conditional computation structures. Structure
definitions. Modeling information with data. The structure of data:
composite, containment, union, self-referential, mutually referential,
cyclically defined. Program design and design recipes: design based on the
structure of data. Extensional equality of structured data. (Automated) testing.
Accumulators. Designing abstractions. Generative recursion.

\paragraph{Course Outcomes:}
%
Upon completion of this course, a student should be able to \emph{design programs},
and, consequently, have some understanding of the fundamentals of computation.
In particular, the student should be able to: Complete data analysis and
definition for problems that require the use of composition, containment,
union, and self-reference. Design programs to solve problems that consume and
produce data structures based on composition, containment, union, and
self-reference. Design test suites for these programs and evaluate the
outcomes. Design simple abstractions and test the design. Reason about the
performance characteristics of programs in a basic way.

\paragraph{Measurement of Course Outcomes:}
%
Outcomes are measured and verified through: Weekly programming homeworks.
Daily short paper-and-pencil quizzes. Two to four major exams. Inclusion of
student's work in an electronic portfolio.

\pagebreak

\section*{CS~2500 Sample Syllabus}

The course sequences through the following topics:
\begin{itemize}
\item overview, intro to simple arithmetic calculation
\item atomic \& compound data: 
  \begin{itemize}
    \item integers
    \item booleans \& conditional computation
    \item records
  \end{itemize}
\item representation: information vs. data
\item data-driven programming
\item testing
\item unions
\item self-referential unions 1---recursion
\item self-referential unions 2---list processing
\item designing larger programs: top-down design; iterative refinement
\item recursion in all forms: trees, s-expressions, forests
\item abstraction: interfaces and implementations
\item abstraction: parametric data definitions and contracts
\item notions of equality
\item local name scope; simple asymptotic complexity
\item abstracting control with higher-order functions
\item constructing higher-order functions with lambda
\item infinite data structures and computations
\item generative recursion: root finding, sorting
\item generative recursion: graphs \& search; accumulators
\item review and wrap up
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% CS2510
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak

\section*{CS~2510 Course Charter}

\paragraph{Course Title:}
%
CS~2510 \emph{Fundamentals of Computer Science 2}	(4 SH)

\paragraph{Course Description:}
%

Introduces the fundamentals of the design of class hierarchies in
object-oriented programming with emphasis on representation-dependent
program design with objects. The course also covers basic reasoning
techniques concerning the correctness and algorithmic behavior of
computations.

\paragraph{Prerequisites:}
%
CS~2500. In addition, CS~1800 Discrete Structures for Computer Science should be taken prior to CS~2510 or concurrently.

\paragraph{Textbooks:}
%
\emph{How to Design Programs}, Felleisen, Flatt, Findler, and Krishnamurthi, MIT Press, 2000. \emph{How to Design Classes}, Felleisen, Flatt, Findler, Krishnamurthi, Gray, and Proulx, in preparation.

\paragraph{Topics Covered:}
%
Objects, classes, class hierarchies.  Data definitions and methods.
%
Class diagrams.
%
Interfaces, abstract classes, subclasses.  Types.  Polymorphism.
%
Accumulators, iterators, loops.
%
Function objects, comparators, visitors.  Sorting: quick sort, merge
sort, heap sort.  Notions of equality.
%
Java collections library.
%
Overriding {\tt equals} and {\tt hashCode}.
%
Testing: unit testing, stress testing, and property-based random testing.
%
Binary trees, binary search, heaps, hash tables.
%
Invariants.
%
Graphs, graph traversal, generative recursion.  Depth-first,
breadth-first, and priority-queue based search.
%
Design patterns.
%
Mutation and stateful programming.
%
Indexed data structures.

\paragraph{Course Outcomes:}
%
Upon completion of this course, a student should be able to: 
(1) Design, implement, and test class hierarchies with appropriate methods. 
(2) Read the documentation of class libraries and write programs that use them appropriately. 
(3) Understand the algorithmic behavior of individual methods.

\paragraph{Measurement of Course Outcomes:}
%
Weekly programming homeworks. Final project. Weekly short paper and pencil quizzes. Two to four major exams. Inclusion of student's work in an electronic portfolio.

\pagebreak

\section*{CS~2510 Sample Syllabus}

The course studies the class-based program design and the design of abstractions that support the design of reusable software and libraries. It covers the principles of object oriented program design, the basic rules of program evaluation, the use of abstractions in support of the design of reusable code, and examines the relationship between algorithms and data structures, as well as basic techniques for analyzing algorithm complexity.

The course is suitable for both CS majors and non-majors. It assumes that student has been introduced to the basic principles of program design and computation.

\paragraph{Course Objectives:}
%
The goal is to help the student understand the principles of class
based program design using an object-oriented programming
language. Java is used to illustrate how the program design principles
are used in practical applications. Using a concrete language also
presents an opportunity to discuss the strengths and weaknesses of
languages and language paradigms.

\paragraph{MODULE 1:}
%
Review of Fundies 1 in the context of a class-based statically typed language (2 weeks)
%
\begin{itemize}
\item Review of the program design and abstractions in functional style;
  design recipe, abstractions, loops with accumulators
\item Defining classes and class hierarchies to represent complex information:
  simple classes, classes with fields that are instances of another class, 
  unions of classes, self-referential and mutually referential class   
  hierarchies: lists, trees, graphs
\item Designing methods for classes: static type system, dynamic dispatch,
  delegation (chain of responsibility)
\item Design Recipe for data definitions, for method definitions
\end{itemize}

\paragraph{MODULE 2:}
%
Designing Abstractions (3 weeks)
%
\begin{itemize}
\item Review of the Design Recipe for Abstractions
\item Abstracting over the data: abstract classes; subclasses
\item Abstracting over the functional behavior: function objects, functional iterator
\item Understanding equality of complex data
\end{itemize}

\paragraph{MODULE 3:}
%
Stateful Programming (3 weeks)
%
\begin{itemize}
\item Designing methods with effects; Designing tests for effects
\item Understanding equality in the presence of mutation
\item Direct access data structures: (e.g. Java ArrayList)
\item Loops
\end{itemize}

\paragraph{MODULE 4:}
%
Abstracting over the Data Type; Designing and using libraries (6 weeks)
%
\begin{itemize}
\item Polymorphism: parametrized classes, methods
\item Abstract Data Type --- stack, queue, list, set
\item Abstract Data Type --- map, hashmap
\item HashCode method and overriding equals method
\item Algorithm complexity --- estimates; Stress tests
\item Java Collection Framework
\end{itemize}

\paragraph{Notes:}
%
\begin{itemize}

\item A number of algorithms (filter, andmap, ormap, linear search, binary search, binary search trees, insertion sort, selection sort, quicksort, heap-based priority queue, heapsort, table lookup, use of hashmap, and some graph traversal algorithms (BFS, DFS, and possibly shortest path) are used to illustrate the program design, the need for appropriate data representation, and the need for understanding the complexity of algorithms.

\item Stress tests are used to reinforce the need for understanding the algorithm complexity.

\item Data structures (stacks, queues, lists, trees, arraylist, hashmap, lookup tables) are presented in the context of problems that motivate their use.

\item The goal is to make sure the students begin to understand the design of class based libraries, know how to look up the needed information, and can begin using libraries in their programs.

\item A comprehensive final project challenges the students to apply the design principles and the knowledge of the libraries to a creative larger program with up to 1000 LOC.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% CS3500
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak

\section*{CS~3500 Course Charter}

\paragraph{Course Title:}
%
CS~3500 \emph{Object-Oriented Design} (4 SH)

\paragraph{Course Description:}
%
Presents the theory and practice of object-oriented programming,
emphasizing abstractions and ideas that scale to large systems.
Introduces representation independence and related concepts such as
information hiding, encapsulation, modularity, and interchangeability
of parts.  Analyzes strengths and weaknesses of alternative
representations by considering asymptotic efficiency for the best,
worst, average, and amortized case.  Illustrates general paradigms
such as divide-and-conquer algorithms, precomputation, caching,
memoization, and dynamic programming.  Covers static types and
explains how subtyping and several forms of polymorphism
(parametric, ad hoc, and inclusion) support design patterns that
contribute to reuse and extensibility.

\paragraph{Prerequisites:}
%
CS~2510. 

\paragraph{Textbooks:}
%
\noindent
Barbara Liskov and John Guttag.
\emph{Program Development in Java: Abstraction, Specification,
and Object-Oriented Design}.
Addison-Wesley, 2001.

\noindent
Peter Sestoft.  \emph{Java Precisely}, Second Edition.
MIT Press, 2005.


\paragraph{Topics Covered:}
%
Object-oriented programming:
%
classes and inheritance,
dynamic method dispatch,
class diagrams for inheritance and composition,
abstract classes and protocols (e.g. Java interfaces),
overriding versus overloading,
immutable versus mutable,
organized approaches to designing objects and classes,
refactoring.
%
Abstraction: 
%
the abstraction barrier,
client perspective versus implementor perspective,
specifications as contracts,
black-box testing against specifications,
substitutability of implementations,
representation independence,
information hiding,
encapsulation,
tradeoffs between information hiding, encapsulation, and reuse.
%
Algorithmic thinking:
%
asymptotic notation,
worst case, best case, average case,
amortized efficiency,
divide-and-conquer algorithms,
precomputation,
caching,
memoization and/or dynamic programming.
%
Static types:
%
compile-time versus run-time,
interactions with reuse,
subtyping,
ad hoc (sum) polymorphism, 
inclusion (product) polymorphism,
parametric polymorphism.
%
Basic design patterns:
%
Factory Method,
Singleton,
Wrapper/Adapter,
Composite,
Iterator,
Functional Visitor.

\paragraph{Course Outcomes:}
%
Upon completion of this course, a student should be able to: 
%
\begin{enumerate}
\item
List and describe fundamental mechanisms of object-oriented
programming, including inheritance, subtyping, polymorphism,
and dynamic method dispatch.
\item
Use at least one object-oriented programming language well
enough to implement abstract data types.
\item
Evaluate implementations of abstract data types with respect
to correctness, abstraction, efficiency, and code reuse.
%\item
%Transfer his or her programming knowledge to other OO languages and
%other programming paradigms.
\end{enumerate}

\paragraph{Measurement of Course Outcomes:}
%
Outcomes are measured and verified through: (1) regular programming
homeworks (five to ten recommended), which may combine to develop
a larger piece of software by the end of the semester; (2) two to four
major exams; (3) inclusion of student's work in an electronic portfolio.

\pagebreak

\paragraph{For reference\ldots}

\paragraph{Current Catalog Description:}
%
Presents a comparative approach to object-oriented programming
and design. Discusses the concepts of object, class, meta-class,
message, method, inheritance, and genericity. Reviews forms of
polymorphism in object-oriented languages. Contrasts the use of
inheritance and composition as dual techniques for software reuse:
forwarding vs. delegation and subclassing vs. subtyping. Fosters
a deeper understanding of the principles of object-oriented
programming and design including software components,
object-oriented design patterns, and the use of graphical design
notations such as UML (unified modeling language). Basic concepts
in object-oriented design are illustrated with case studies in
application frameworks and by writing programs in one or more
object-oriented languages.

\paragraph{Course Description As Stated In Obsolete Course Charter:}
%
Presents a comparative approach to object-oriented
programming and design, with an emphasis on techniques for programming
large-scale systems. Discusses the concepts of object, class,
meta-class, message, method, inheritance, and genericity. Reviews
forms of polymorphism in object-oriented languages. Contrasts the use
of inheritance and composition as dual techniques for software reuse:
forwarding versus delegation and sub-classing versus
sub-typing. Studies main programming language tools and techniques to 
facilitate the creation of applications: modularity, encapsulation,
code reuse techniques, design patterns. Basic concepts in
object-oriented design are illustrated by writing programs in one or
more object-oriented languages. 

\paragraph{Course Description As Stated in Online Course Charter:}
%
The course presents the theory and practice of object-oriented
programming. The course enhances students understanding of the
concepts of object, class, message, method, inheritance, and
genericity. The course covers a basic model for objects; the
principles of types and polymorphism in object-oriented programming
languages; different forms of abstraction; and theory and practice
of reuse. The course also introduces students to some
object-oriented design patterns that practitioners have found useful. 

\pagebreak

\section*{CS~3500 Sample Syllabus}

The theme of the course is representation independence and
its contribution to algorithmic creativity.

That theme presents a clean break from Fundies 2, in which
students are taught how to write code that mirrors the
structure of their data.  The representation-dependent
approach taken in Fundies 2 is appropriate for implementors
of an abstract data type, but is inappropriate for the ADT's
clients.

CS 3500 introduces the abstraction barrier that separates
clients from implementors.  Implementors must know how values
of an ADT are representated, but clients should not.  Making
client code independent of the representation makes it possible
for implementors to change representations without breaking
client code.  Representation independence allows implementors
to replace naive implementations by implementations that use
more sophisticated representations and algorithms.

CS 3500 should be taught using a programming langauge that
provides adequate support for class-based inheritance and for
information hiding.  Although Java has been used to teach most
sections of CS 3500, mainly because students are taught Java in
Fundies 2, some instructors have taught CS 3500 using Smalltalk
or Scala.  For concreteness, the sample syllabus below will
assume the language is Java.



\paragraph{MODULE 1:}
%
ADTs and Representation Independence (3 weeks)
%
\begin{itemize}
\item the abstraction barrier
\item ADTs, signatures, specifications
\item algebraic specifications of immutable ADTs
\item the Factory Method pattern hides representations from clients
\item UML class diagrams
\item the recipe representation
\item translation of algebraic specifications into idiomatic OO code
\item help clients out by throwing exceptions for unspecified cases
\item axiomatic specifications of equals(Object) and hashCode()
      may hide some representation details
\item substitution principle:
      all implementations that satisfy the specification are interchangeable
\item black-box testing against specification
\end{itemize}

\paragraph{MODULE 2:}
%
Taking Advantage of Representation Independence (4 weeks)
%
\begin{itemize}
\item parametric polymorphism
\item asymptotic notation (big-O, Omega, Theta)
\item best, average, and worst case
\item general rules for improving performance
\begin{itemize}
\item Don't.
\item Don't yet.
\item Don't optimize any more than necessary.
\end{itemize}
\item general paradigms of algorithm design
\begin{itemize}
\item Don't compute things you don't need to compute.
\item Don't recompute things you can avoid recomputing.
\begin{itemize}
\item divide and conquer
\item precomputation
\item caching
\item memoization and/or dynamic programming
\end{itemize}
\end{itemize}
\item refactoring transformations
\item invariants
\item more efficient representations
\end{itemize}

\paragraph{MODULE 3:}
%
Software Reuse (2 weeks)
%
\begin{itemize}
\item the Functional Visitor pattern
\item the Iterator pattern
\item mutable state versus concurrency
\item reuse by inheritance versus reuse by composition
\item protocols (which Java calls interfaces)
\item the fragile base class problem
\end{itemize}

\paragraph{MODULE 4:}
%
Static Types (2 weeks)
%
\begin{itemize}
\item safety properties and type errors
\item interaction with reuse
\item subtyping
\item sum and product types
\item ad hoc and inclusion polymorphism
\item bounded parametric polymorphism
\item covariant, contravariant, and monovariant type constructors
\end{itemize}

\end{document}