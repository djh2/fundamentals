\documentclass[submission,copyright]{eptcs}
\providecommand{\event}{TFPIE} % Name of the event you are submitting to

\usepackage[numbers]{natbib}
\usepackage{xspace}

\newcommand\thetitle{From Principles to Practice with Class in the First Year}

\title{\thetitle}
\author{Sam Tobin-Hochstadt \quad\qquad David Van Horn
\institute{Northeastern University\\
Boston, Massachusetts, USA}
\email{\{samth,dvanhorn\}@ccs.neu.edu}
}
\def\titlerunning{\thetitle}
\def\authorrunning{S. Tobin-Hochstadt \& D. Van Horn}
\begin{document}
\maketitle

\begin{abstract}
We propose a bridge between functional and object-oriented programming
in the first-year curriculum.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Many universities and colleges aim to teach their students proficiency
in an industrial object-oriented programming language by the end of
the students' first year.  Past approaches to achieve this aim have
included teaching an industrial language, such as Java, starting on
the first day.  Others have taken a more indirect route by teaching
functional programming in the first semester, followed by a second
semester that starts in Java.  The latter approach is an improvement
over the first, but both suffer serious flaws.

As an example, Northeastern University teaches functional programming
in the first semester using \emph{How to Design
  Programs}~\cite{dvanhorn:Felleisen2001How}, followed by
object-oriented programming using \emph{How to Design
  Classes}~\cite{local:htdc} in the second semester.  This sequence
was designed to provide a smooth path for incoming students assumed
only to have a competence in high-school level algebra to reach
proficiency in Java by the end of their first year
\cite{dvanhorn:Felleisen2004Structure}.  It was a major improvement
over the previous Java-first curriculum in terms of student success,
attrition, and preparation for subsequent
courses~\cite{dvanhorn:Proulx2006Design}.  However, significant
problems remain; in particular, the second semester course violates
the designers' own principles (as recalled
in~\cite{dvanhorn:Bloch2000Scheme}):
%
\begin{enumerate}
\item \emph{introduce only those language constructs that are necessary to
  teach programming principles}, and
\item \emph{choose a language with as
  few language constructs as possible, and one in which they can be
  introduced one at a time}.
\end{enumerate}

The problem is that the first semester ends with an advanced
pedagogical functional language and the second semester starts with a
beginning pedagogical subset of Java.  Despite this slimmed-down
subset, this transition is too abrupt to meaningfully bridge the gap
between functional and object-oriented programming, because there are
several other significant transitions happening in concert such as the
transitions:
\begin{itemize}
\item from a highly regular and minimal syntax to a complicated
  irregular syntax,

\item from an untyped language to a typed language,

\item from a pedagogical programming environment to a professional
programming environment (Eclipse),

\item from a language with numeric values corresponding to
  mathematical objects to a language with numeric values corresponding
  to common machine representations,

\item from a language with image literals and graphical libraries to
  one in which graphical programming is tedious,

\item from an interaction-oriented language to a compiled,
  batch-oriented language.  
\end{itemize}

This abrupt transition has several negative consequences: the
principles of object-oriented programming are obscured and
de-emphasized, struggling with the programming environment is
frustrating and can cause potentially good students to leave the
program, it favors students with prior exposure to the particular
tools, it inhibits students from experimenting by relying upon their
past skills, and it creates the false impression that courses are
discrete units of instruction that can be discarded after successful
completion rather than being part of a continuous and cumulative
educational experience.


We contribute an alternative approach to the second semester that
overcomes these problems and provides a gradual transition from
functional programming to object-oriented programming.  Our approach
is able to start the second semester by introducing \emph{only} the
concept of programming with objects, while all other aspects of course
remain where they were left off in the previous semester.  This
approach allows the other concepts to be introduced at the point at
which they are relevant and motivated.  Despite this more gradual
approach, the course accomplishes the goal of teaching industrial
language proficiency by the end of the semester, covering a super-set
of the concepts and topics covered in the \emph{How to Design Classes}
course.

\paragraph{Outline} The remainder of this paper is organized as follows:
in section~\ref{sec:background} provides background on \emph{How to
  Design Programs} and the context and constraints involved in the
first-year at Northeastern.  Section~\ref{sec:shift} describes our
approach to the second semester, which starts with a small shift in
perspective to bridge the gap between functional programming and
object oriented programming.  Section~\ref{sec:industrial} describes
the path toward programming in an industrial object-oriented
programming language.  Section~\ref{sec:related-work} discusses the
relation to existing work and section~\ref{sec:conclusion} concludes.

%% \cite{local:dpc}

%% Some of these are premature, and better introduced later in the
%% course.  Some are just irrelevant trivia (different syntax) that often
%% favors ``experienced'' students while needlessly intimidating students
%% with only the previous semester under their belt.  Many of these
%% trivial matters, e.g. Eclipse configuration, javac command line
%% arguments, the CLASSPATH, can be very frustrating to the uninitiated,
%% causing students to believe struggling with such crap is \emph{the
%%   essence of computer science}.  Bright, promising students may leave
%% the program, understandably so, in order to pursue more intellectually
%% fulfilling subjects.


\section{Background: the context at Northeastern}
\label{sec:background}

At Northeastern, the College of Computer \& Information Science (CCIS)
requires a four course introductory sequence in the first year.  The
first semester features both a course on discrete mathematics and
 an introduction to programming following the \emph{How to Design
  Programs} curriculum.  The second semester follows with a course on
object-oriented programming and one featuring formal reasoning about
programs, both on paper and with the ACL2 theorem
prover~\cite{dvanhorn:Kaufmann2000ComputerAided}.

Subsequent to the first year, students take a wide variety of
follow-up courses, ranging from a required course in ``Object-oriented
design'' to architecture, operating systems, robotics, and programming
languages.  No standard language is used in these courses.  

More significantly, Northeastern distinctively emphasizes experiential
education, with almost all Computer Science majors participating in a
6 month ``co-op'' internship after their third semester.  These co-ops
take place at a wide variety of companies, and while most students do
some software development, there is almost no uniformity beyond that. 

This combination sets the constraints under which we designed our
approach.  Our students begin the course with a firm grasp of
data-driven program design, as well as experience with the tools used
in the first course:

\begin{itemize}
  \item the student languages introduced in \emph{How to Design
    Programs}~\cite{dvanhorn:Felleisen2004Structure,
    dvanhorn:Felleisen2001How} as well as the idea of ``language levels'';

  \item the DrRacket (formerly DrScheme) 
    programming environment~\cite{dvanhorn:Findler2002DrScheme};

  \item the \texttt{check-expect} testing framework~\cite{local:check-expect};

  \item the ``World'' approach to developing interactive animations
    and games using functional
    programming~\cite{dvanhorn:Felleisen2009Functional}.
\end{itemize}

\noindent
We reuse all of these elements in our approach.

After our course, our students should both (a) be prepared for
subsequent courses in the curriculum, which expect familiarity with
Java and standard Java libraries, (b) be prepared for co-ops in which
they will use professional-grade languages and tools which will
almost certainly be object-oriented.  More significantly, we aim to
teach the key insights behind the object-oriented approach to program
design.

These constraints, while in detail specific to Northeastern and the
CCIS curriculum, are broadly similar to the requirements for the first
year at many universities.  Our course also attends to smaller and
more idiosyncratic elements of our curriculum, ranging from formal
reasoning to algorithmic analysis, as described in the following
sections.



\section{A small shift of focus}
\label{sec:shift}

On the first day of the second semester, we introduce a single
linguistic concept to an otherwise unchanged context of the previous
semester: the idea of an object.
%
An object is a new kind of value that can, as a first cut, be
understood as a pairing together of two familiar concepts: data and
functionality.

\begin{itemize}
\item An object is like a structure in that it has a fixed number of
fields, thus an object (again, like a structure) can represent
compound data. But unlike a structure, an object contains not just
data, but functionality too;

\item An object is like a (set of) function(s) in that it has behavior---it computes; it is
not just inert data.
\end{itemize}

This suggests that objects are a natural fit for well-designed programs
since good programs are organized around data definitions and
functions that operate over such data. An object, in essence, packages
these two things together into a single programming apparatus. This
has two important consequences:

\begin{enumerate}

\item Students already know how to design programs oriented around objects.

Since objects are just the combination of two familiar concepts that
students already use to design programs, they already know how to
design programs around objects, even if they have never heard the term
``object'' before.

\item Objects enable new kinds of abstraction and composition.

Although the combination of data and functionality may seem simple,
objects enable new forms of abstraction and composition. That is,
objects open up new approaches to the construction of computations. By
studying these new approaches, we can distill new design
principles. Because we understand objects are just the combination of
data and functionality, we can understand how all of these principles
apply in the familiar context of programming with functions. 
\end{enumerate}

\subsection{The basics of objects}

To begin with, we introduce the notion of a \emph{class definition},
which can be thought of at first as a structure definition in that
it defines a new class of compound data.  A class is defined using the
{\tt define-class} form:
\begin{verbatim}
    (define-class posn (fields x y))
\end{verbatim}
An \emph{object} is a value that is a member of this class of data,
which can be constructed with the {\tt new} keyword, a class name, and
the appropriate number of arguments for the fields of the object:
\begin{verbatim}
    (new posn 3 4)
\end{verbatim}
An object understands some set of \emph{messages}.  Simple
structure-like objects understand messages for accessing their fields
and message are sent by using the {\tt send} keyword, followed by an object,
a message name, and some number of arguments:
\begin{verbatim}
    (send (new posn 3 4) x) ;=> 3
    (send (new posn 3 4) y) ;=> 4
\end{verbatim}
The {\tt send} notation is simple, but syntactically heavy.  Once
students are comfortable with the {\tt send} form, we introduce a
shorthand to make it more convenient by writing {\tt (x . m)} for {\tt
  (send x m)}.  The \emph{dot notation} can be nested, so {\tt (x . m
  . n)} is shorthand for {\tt (send (send x m) n)}.  (The approach of
introducing a simple, uniform syntax and later introducing a
convenient shorthand that would have been confusing to start with
follows the approach of introducing {\tt cons} and later {\tt list}
and {\tt quote} in the first semester.)


It is possible to endow objects with functionality by defining \emph{methods},
which extend the set of messages an object understands.  A method definition
follows the same syntax as a function definition, but is located inside of a
class definition.  Here is a more complete development of the {\tt posn} class
that includes a couple of methods:
\begin{verbatim}
    ;; A Posn is a (new posn Number Number),
    ;; which represents a point on the Cartesian plane
    (define-class posn (fields x y)

      ;; Posn -> Number
      ;; Distance between this posn and that posn
      (check-expect ((new posn 0 0) . dist (new posn 3 4)) 5)
      (define (dist that)
        (sqrt (+ (sqr (- (this . x) (that . x)))
                 (sqr (- (this . y) (that . y))))))

      ;; -> Number
      ;; Distance of this posn from the origin
      (check-expect ((new posn 0 0) . dist-origin) 0)
      (check-expect ((new posn 3 4) . dist-origin) 5)
      (define (dist-origin)
        (this . dist (new posn 0 0))))
\end{verbatim}

This class definition defines a new class of values which are {\tt
  posn} objects.  Such objects are comprised of two numeric values
and understand the messages {\tt x}, {\tt y}, {\tt dist}, and {\tt
  dist-origin}.  Unit tests have been included with each method
definition, following the principles of the design recipe studied in
the first semester.  In fact, the {\tt check-expect} mechanism works
exactly as it did before.

Methods can be defined to consume any number of arguments, but they
are implicitly parameterized over {\tt this}, the object that was sent
the message.

\subsection{Where did the {\tt cond} go?}

Unions, and recursive unions in particular, are a fundamental kind of
data definition that students are well-versed in from the previous
semester.  A fundamental early lesson is how to represent (recursive)
unions using classes and how to write recursive methods.  As an
example, figure~\ref{fig:tree} defines binary trees of numbers
(an archetypical recursive union data definition)
using the BSL language and the Class language.
%% \begin{verbatim}
%%     ;; A list of numbers (LoN) is one of:
%%     ;; - (new empty%)
%%     ;; - (new cons% Number LoN)

%%     (define-class empty%
%%       ;; Length of this empty list
%%       (check-expect ((new empty%) . len) 0)
%%       (define (len) 0))

%%     (define-class cons% (fields first rest)
%%       ;; Length of this cons list
%%       (check-expect ((new cons% 7 (new empty%)) . len) 1)
%%       (define (len)
%%         (add1 (this . rest . len))))
%% \end{verbatim}

\begin{figure}[h!]
\begin{minipage}[t]{3.5in}
\begin{verbatim}
#lang bsl
;; A Tree is one of:
;; - (make-leaf Number)
;; - (make-node Tree Number Tree)
(define-struct leaf (v))
(define-struct node (left v right))

;; sum : Tree -> Number
;; sums the elements of the given tree
(define (sum a-tree)
  (cond [(leaf? a-tree) (leaf-v a-tree)]
        [else
        (+ (sum (node-left  a-tree))
           (node-v a-tree)
           (sum (node-right a-tree)))]))




(check-expect (sum (make-leaf 7)) 7)
(check-expect 
  (sum (make-node
         (make-leaf 1)
         5 
         (make-node (make-leaf 0)
                    10
                    (make-leaf 0))))
  16)
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
#lang class/1
;; A Tree is one of:
;; - (new leaf Number)
;; - (new node Tree Number Tree)
;; and implements
;; sum : -> Number
;; sums the elements of this tree

(define-class leaf
  (fields v)
  (define (sum) (this . v)))

(define-class node
  (fields left v right)
  (define (sum)
    (+ (this . left . sum)
       (this . v)
       (this . right .sum))))

(check-expect ((new leaf 7) . sum) 7)
(check-expect 
  ((new node
        (new leaf 1)
        5 
        (new node (new leaf 0) 
                  10
                  (new leaf 0))))
    . sum)
  16)
\end{verbatim}
\end{minipage}
\caption{Binary tree sum in Beginning Student and in the Class language}
\label{fig:tree}
\end{figure}

The structure of this data definition is analagous to the approach of
the previous semester but this example brings to light an important
difference with the functional approach.  The method for computing the
sum of the empty tree is defined in the {\tt leaf} class, while the
method for computing the sum of a node is in the {\tt node} class.
When a tree object is sent the {\tt sum} method, there is no function
with a conditional to determine whether the object is a
leaf---instead, the object itself takes care of computing the sum
based on the {\tt sum} method it contains.  This shift in perspective
is at the core of object-orientation: objects contain their own
behavior and the case analysis previously done in functions is
eliminated.


%% The semester starts with the minimal conceptual change from the
%% previous semester: the addition of objects (same IDE, same syntax,
%% same semantics [just a new kind of value], same interactive video
%% games, etc.).



\subsection{Worlds and animations}

Programming in the first semester is often oriented around interactive
event-driven video games.  The basic design of a video game involves
defining a data representation for states of the game and functions
for transitioning between states based on events such as clock ticks,
keyboard input, or mouse events.  The design of a game thus involves
the design of data and functions on that data; in other words, the
game involves the design of objects.  We therefore continue in the
second semester with the use of programming video games but supplement
the course with a library for doing so in an object-oriented style.
Figure~\ref{fig:world} gives an example written in both the functional
style and object-oriented style.

\begin{figure}
\begin{minipage}[t]{3.4in}
\begin{verbatim}
#lang bsl
(require 2htdp/image 2htdp/universe)

;; A World is a Number

;; on-tick : World -> World
(define (tick w)
  (add1 w))

;; to-draw : World -> Image
(define (draw w)
  (circle w "solid" "red"))

;; on-key : KeyEvent World -> World
(define (on-key k w) 10)

(big-bang 10
          [to-draw draw]
          [on-tick tick])
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
#lang class/1
(require 2htdp/image class/universe)

;; A World is a (new world Number)
(define-class world
  (fields n)

  ;; on-tick : -> World
  (define (on-tick)
    (new world (add1 (this . n))))

  ;; to-draw : -> Image
  (define (to-draw) 
    (circle (this . n) "solid" "red"))

  ;; on-key : KeyEvent -> World
  (define (on-key k) (new world 10)))
  
(big-bang (new world 10))
\end{verbatim}
\end{minipage}
\caption{World programs}
\label{fig:world}
\end{figure}


\subsection{Language levels}

No SE tools/mechanism built into the language.

\subsection{Universe}

\subsection{Programming to interfaces}








\section{From principles to industrial languages}
\label{sec:industrial}

Could work with any fashion, and should really lead into many
fashionable languages.  The purpose of showing many is to demonstrate
that the same principles apply in each setting.  Each language can also
expose students to various mechanisms.

\begin{figure}
\begin{verbatim}
import tester.*;

interface Tree {
    // sums the elements of this tree
    Integer sum();
}

class Leaf {
    Integer v;
    Leaf(Integer v) { this.v = v; }
    public Integer sum() { return this.v; }
}

class Node {
    Tree left; Integer v; Tree right;
    Node(Tree l, Integer v, Tree r) {
        this.left = l;
        this.v = v;
        this.right = r;
    }

    public Integer sum() {
        return this.left.sum() + this.v + this.right.sum();
    }
}

class Examples {
    void test_tree(Tester t) {
        t.checkExpect(new Leaf(7).sum(), 7);
        t.checkExpect(new Node(new Leaf(1),
                               5, 
                               new Node(new Leaf(0), 10, new Leaf(0))).sum(),
                      16);
    }
}
\end{verbatim}
\caption{Binary tree sum in How to Design Classes}
\end{figure}


\subsection{Java}

\begin{itemize}
\item Types
\item Compiler
\item ``Industrial'' features (collections library, ...)
\end{itemize}



\subsection{Unifying functions and objects}


\section{Related work}
\label{sec:related-work}

Teaching programming principles in a functional style has a long
history, with Abelson and Sussman's \emph{Structure and Interpretation
of Computer Programs}~\cite{dvanhorn:sicp} a prominent example.  Our
work follows in the tradition of the \emph{TeachScheme!} project, now
\emph{Program by Design} (PbD), which emphasizes a systematic
approach to program construction.  

Since the introduction of functional-first curricula, and more
specifically in the Program by Design framework, numerous courses have
tackled the problem of transition.  Typically they, as we, transition
to Java in the second course.  We discuss first the approach developed
by some of the principal creators of PbD, and then other approaches.

\subsection{TeachScheme! and ProfessorJ}

The TeachScheme! project initially focused only on the first course,
with the second course typically taught in Java in
institution-specific ways. Subsequently, the pedagogical approach was
extended to Java, but without the tool support and textbook of the
first course.  An example of this approach is described by
\citet{dvanhorn:Bloch2000Scheme}, who presents the experience
integrating these courses at Adelphi.  He reports that ``many of
Java's concepts could be introduced more easily in a second course
than a first''.

With these lessons in mind, the TeachScheme! project set out to apply
the lessons of teaching languages and IDE support to Java, as well as
to present the approach to object-oriented programming in textbook
form. ProfessorJ~\cite{dvanhorn:Gray2003ProfessorJ} is the resulting
system, accompanying the draft textbook \emph{How to Design
  Classes}~\cite{local:htdc}.  In parallel to our course, Northeastern
teaches the remainder of its computer science majors following this
approach.

ProfessorJ and How to Design Classes maintain many of the excellent
ideas of the first course.  In particular, ProfessorJ brings language
levels to Java, in an attempt to smooth the transition for students
from the first course and provide more helpful feedback.  ProfessorJ
is also embedded in the DrRacket IDE, increasing familiarity for the
students and supporting tools such as an interactive read-eval-print
loop. 

\def\htdp{\emph{How to Design Programs}\xspace}
\def\htdc{\emph{How to Design Classes}\xspace}
\def\profj{{ProfessorJ}\xspace}

However, the ``day 1'' transition from the student languages used with
\htdp to \profj is too abrupt and too large.
%
Most significantly, changing languages from the first semester
immediately rather than simply adding a new concept confuses too many
issues for students.  On the first day of a \htdc-based course,
students see object-orientation, a new programming paridigm; Java, a
new language with new syntax, and static types, a crucial but
orthogonal concept.
%
In contrast, our course presents just one of these concepts on the
first day, but  covers all of them by the end of the semester.

\profj also takes on the the dual challenges of implementing Java as
well as subsetting it.  This ultimately resulted in both a limited
Java environment as well as the eventual abandoning of the tool since
it was too difficult to maintain, let alone keep up with advances in
Java.  

Finally, committing to Java on the first day, regardless of the
environment provided to students, has significant limitations.  First,
the syntactic and semantic heaviness of Java is a burden for beginning
students, and discourages interactive and experimental programming.
The very first chapter of \htdc discusses the fixed size of Java integers,
a topic avoided entirely in the first course.
Second, by committing to a particular industrial-strength language, it
closes off possibilities in the curriculum.  Third, it commits
entirely to the new paradigm, making it more difficult for students to
compare the approaches. 

Since \profj is no longer available, students are faced with an even
starker change on the first day.  Even with a student-oriented
environment such as DrJava or BlueJ~\cite{dvanhorn:Allen2002DrJava,
  dvanhorn:Hsia2005Taming}, students must learn an entirely new tool,
along with new libraries.
If the course uses a typical professional development environment such
as Eclipse, students must also contend with compilation, loss of
interactivity, and subtle issues such as classpaths, none of which are
fundamental to the concepts that the course focuses on.


\subsection{Other transitions}

Of course, not every curriculum that begins with \htdp transitions to
Java after the first course.  \citet{dvanhorn:Ragde2008Chilling}
describes a second course that includes both more advanced work in
Scheme beyond teaching-oriented languages as well as low-level
programming in C, taught to computer science majors at University of
Waterloo.  Radge's course intentionally does not use student-oriented
languages, although the recently-developed C0 language~\cite{local:c0}
could provide this. Other discussions of functional programming in the
first year~\cite{dvanhorn:Chakravarty2004Risks} do not discuss the
problems of transition.

\subsection{Other approaches to Java}

The problems of teaching Java in introductory courses have been
well-explored; we mention only a few related directions here.
DrJava~\cite{dvanhorn:Allen2002DrJava} and
BlueJ~\cite{dvanhorn:Hsia2005Taming,dvanhorn:Kolling2003} are
introductory environments for Java, which alleviate some but not all
of the drawbacks we have outlined.
%
Several teaching-oriented graphics libraries for Java have been
proposed~\cite{dvanhorn:Bruce2001Library,dvanhorn:Alphonce2003Using},
but these are significantly more complex than the graphics and
interaction libraries we are able to use in the introductory language
we present.


[Move me: \cite{local:barland-sfp10}]

\section{Experience and outlook}
\label{sec:conclusion}

Perspective into the upper-class curriculum:

\begin{itemize}
\item types, contract, invariants : formal methods, program verification,
  
\item representation independence : component-based software engineering,
  data-structures, algorithms

\item interfaces, interactions, distribution : operating systems, networking
\end{itemize}


Other steps:
\begin{itemize}
\item types in class language
\item pedagogical Java environment
\item ugly syntax for class language
\item world in Java
\end{itemize}

\cite{dvanhorn:sicp}

\cite{local:htdc}

\subsection*{Acknowledgements}

Matthias Felleisen's approach to pedagogy and passion for
undergraduate teaching has inspired this work from the beginning.
CCIS Dean Larry Finkelstein entrusted two postdocs with the redesign
of a key undergraduate course, which made this experiment possible.
Our teaching assistants, Dan Brown, Asumu Takikawa, and Nicholas
Labich, as well as the tutors and graders, contributed enormously to
the success of our courses. Finally, and most importantly, our
students at Northeastern for the last three years have put up with a
curriculum in progress, and the opportunity to teach them has been
truly rewarding.

% \nocite{*}
\bibliographystyle{plainnat}
\bibliography{dvh-bibliography,local}
\end{document}
