\documentclass[submission,copyright]{eptcs}
\providecommand{\event}{TFPIE} % Name of the event you are submitting to

\newcommand\thetitle{From Principles to Practice with Class in the First Year}

\title{\thetitle}
\author{Sam Tobin-Hochstadt \quad\qquad David Van Horn
\institute{Northeastern University\\
Boston, Massachusetts, USA}
\email{\{samth,dvanhorn\}@ccs.neu.edu}
}
\def\titlerunning{\thetitle}
\def\authorrunning{S. Tobin-Hochstadt \& D. Van Horn}
\begin{document}
\maketitle

\begin{abstract}
We propose a bridge between functional and object-oriented programming
in the first-year curriculum.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Many universities and colleges aim to teach their students proficiency
in an industrial object-oriented programming language by the end of
the students' first year.  Past approaches to achieve this aim have
included teaching an industrial language, such as Java, starting on
the first day.  Others have taken a more indirect route by teaching
functional programming in the first semester, followed by a second
semester that starts in Java.  The latter approach is an improvement
over the first, but both suffer serious flaws.

As an example, Northeastern University teaches functional programming
in the first semester using \emph{How to Design
  Programs}~\cite{dvanhorn:Felleisen2001How}, followed by
object-oriented programming using \emph{How to Design
  Classes}~\cite{local:htdc} in the second semester.  This sequence
was designed to provide a smooth path for incoming students assumed
only to have a competence in high-school level algebra to reach
proficiency in Java by the end of their first year
\cite{dvanhorn:Felleisen2004Structure}.  It was a major improvement
over the previous Java-first curriculum in terms of student success,
attrition, and preparation for subsequent
courses~\cite{dvanhorn:Proulx2006Design}.  However significant
problems remain; in particular, the second semester course violates
the designers' own principles (as recalled
in~\cite{dvanhorn:Bloch2000Scheme}):
%
\begin{enumerate}
\item \emph{introduce only those language constructs that are necessary to
  teach programming principles}, and
\item \emph{choose a language with as
  few language constructs as possible, and one in which they can be
  introduced one at a time}.
\end{enumerate}

The problem is that the first semester ends with an advanced
pedagogical functional language and the second semester starts with a
beginning pedagogical subset of Java.  Despite this slimmed-down
subset, this transition is too abrupt to meaningfully bridge the gap
between functional and object-oriented programming, because there are
several other significant transitions happening in concert such as the
transitions:
\begin{itemize}
\item from a highly regular and minimal syntax to a complicated
  irregular syntax,

\item from an untyped language to a typed language,

\item from a pedagogical programming environment to a professional
programming environment (Eclipse),

\item from a language with numeric values corresponding to
  mathematical objects to a language with numeric values corresponding
  to common machine representations,

\item from a language with image literals and graphical libraries to
  one in which graphical programming is tedious,

\item from an interaction-oriented language to a compiled,
  batch-oriented language.  
\end{itemize}

This abrupt transition has several negative consequences: the
principles of object-oriented programming are obscured and
de-emphasized, struggling with the programming environment is
frustrating and can cause potentially good students to leave the
program, it favors students with prior exposure to the particular
tools, it inhibits students from experimenting by relying upon their
past skills, and it creates the false impression that courses are
discrete units of instruction that can be discarded after successful
completion rather than being part of a continuous and cumulative
educational experience.


We contribute an alternative approach to the second semester that
overcomes these problems and provides a gradual transition from
functional programming to object-oriented programming.  Our approach
is able to start the second semester by introducing \emph{only} the
concept of programming with objects, while all other aspects of course
remain where they were left off in the previous semester.  This
approach allows the other concepts to be introduced at the point at
which they are relevant and motivated.  Despite this more gradual
approach, the course accomplishes the goal of teaching industrial
language proficiency by the end of the semester, covering a super-set
of the concepts and topics covered in the \emph{How to Design Classes}
course.

\paragraph{Outline} The remainder of this paper is organized as follows:
in section~\ref{sec:background} provides background on \emph{How to
  Design Programs} and the context and constraints involved in the
first-year at Northeastern.  Section~\ref{sec:shift} describes our
approach to the second semester, which starts with a small shift in
perspective to bridge the gap between functional programming and
object oriented programming.  Section~\ref{sec:industrial} describes
the path toward programming in an industrial object-oriented
programming language.  Section~\ref{sec:related-work} discusses the
relation to existing work and section~\ref{sec:conclusion} concludes.

%% \cite{local:dpc}

%% Some of these are premature, and better introduced later in the
%% course.  Some are just irrelevant trivia (different syntax) that often
%% favors ``experienced'' students while needlessly intimidating students
%% with only the previous semester under their belt.  Many of these
%% trivial matters, e.g. Eclipse configuration, javac command line
%% arguments, the CLASSPATH, can be very frustrating to the uninitiated,
%% causing students to believe struggling with such crap is \emph{the
%%   essence of computer science}.  Bright, promising students may leave
%% the program, understandably so, in order to pursue more intellectually
%% fulfilling subjects.


\section{Background: the context at Northeastern}
\label{sec:background}

At Northeastern, the College of Computer \& Information Science (CCIS)
requires a four course introductory sequence in the first year.  The
first semester features both a course on discrete mathematics as well
as an introduction to programming following the \emph{How to Design
  Programs} curriculum.  The second semester follows with a course on
object-oriented programming and one featuring formal reasoning about
programs, both on paper and with the ACL2 theorem
prover~\cite{dvanhorn:Kaufmann2000ComputerAided}.

Subsequent to the first year, students take a wide variety of
follow-up courses, ranging from a required course in ``Object-oriented
design'' to architecture, operating systems, robotics, and programming
languages.  No standard language is used in these courses.  

More significantly, Northeastern distinctively emphasizes experiential
education, with almost all Computer Science majors participating in a
6 month ``co-op'' internship after their third semester.  These co-ops
take place at a wide variety of companies, and while most students do
some software development, there is almost no uniformity beyond that. 

This combination sets the constraints in which we designed our
approach.  Our students begin the course with a firm grasp of
data-driven program design, as well as experience with the tools used
in the first course:

\begin{itemize}
  \item the student languages introduced in \emph{How to Design
    Programs}~\cite{dvanhorn:Felleisen2004Structure,
    dvanhorn:Felleisen2001How} as well as the idea of ``language levels'';

  \item the DrRacket (formerly DrScheme) 
    programming environment~\cite{dvanhorn:Findler2002DrScheme};

  \item the \texttt{check-expect} testing framework~\cite{local:check-expect};

  \item the ``World'' approach to developing interactive animations
    and games using functional
    programming~\cite{dvanhorn:Felleisen2009Functional}.
\end{itemize}

\noindent
We reuse all of these elements in our approach.

After our course, our students should both (a) be prepared for
subsequent courses in the curriculum, which expect familiarity with
Java and standard Java libraries, (b) be prepared for co-ops in which
they will use professional-grade languages and tools which will
almost certainly be object-oriented.  More significantly, we aim to
teach the key insights behind the object-oriented approach to program
design.

These constraints, while in detail specific to Northeastern and the
CCIS curriculum, are broadly similar to the requirements for the first
year at many universities.  Our course also attends to smaller and
more idiosyncratic elements of our curriculum, ranging from formal
reasoning to algorithmic analysis, as described in
section~\ref{sec:our-course}.



\section{A small shift of focus}
\label{sec:shift}

The semester starts with the minimal conceptual change from the
previous semester: the addition of objects (same IDE, same syntax,
same semantics [just a new kind of value], same interactive video
games, etc.).

\subsection{Side-by-side example of program design}

In intermediate student:

\begin{figure}
\begin{minipage}[t]{3.5in}
\begin{verbatim}
#lang bsl
;; A Tree is one of:
;; - (make-leaf Number)
;; - (make-node Tree Number Tree)
(define-struct leaf (v))
(define-struct node (left v right))

;; sum : Tree -> Number
;; sums the elements of the given tree
(define (sum a-tree)
  (cond [(leaf? a-tree) (leaf-v a-tree)]
        [else
        (+ (sum (node-left  a-tree))
           (node-v a-tree)
           (sum (node-right a-tree)))]))




(check-expect (sum (make-leaf 7)) 7)
(check-expect 
  (sum (make-node
         (make-leaf 1)
         5 
         (make-node (make-leaf 0)
                    10
                    (make-leaf 0))))
  16)
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
#lang class/1
;; A Tree is one of:
;; - (new leaf% Number)
;; - (new node% Tree Number Tree)
;; and implements
;; sum : -> Number
;; sums the elements of this tree

(define-class leaf%
  (fields v)
  (define (sum) (this . v)))

(define-class node%
  (fields left v right)
  (define (sum)
    (+ (this . left . sum)
       (this . v)
       (this . right .sum))))

(check-expect (sum (new leaf% 7)) 7)
(check-expect 
  (sum (new node%
         (new leaf% 1)
         5 
         (new node% (new leaf% 0) 
                    10
                    (new leaf% 0))))
  16)
\end{verbatim}
\end{minipage}
\caption{Binary tree sum in Beginning Student and in our language}
\end{figure}

\begin{figure}
\begin{verbatim}
import tester.*;

interface Tree {
    // sums the elements of this tree
    Integer sum();
}

class Leaf {
    Integer v;
    Leaf(Integer v) { this.v = v; }
    public Integer sum() { return this.v; }
}

class Node {
    Tree left; Integer v; Tree right;
    Node(Tree l, Integer v, Tree r) {
        this.left = l;
        this.v = v;
        this.right = r;
    }

    public Integer sum() {
        return this.left.sum() + this.v + this.right.sum();
    }
}

class Examples {
    void test_tree(Tester t) {
        t.checkExpect(new Leaf(7).sum(), 7);
        t.checkExpect(new Node(new Leaf(1),
                               5, 
                               new Node(new Leaf(0), 10, new Leaf(0))).sum(),
                      16);
    }
}
\end{verbatim}
\caption{Binary tree sum in How to Design Classes}
\end{figure}


\begin{figure}
\begin{minipage}[t]{3.4in}
\begin{verbatim}
#lang bsl
(require 2htdp/image 2htdp/universe)

;; A World is a Number

;; on-tick : World -> World
(define (tick w) (add1 w))

;; to-draw : World -> Image
(define (draw w)
  (circle w "solid" "red"))

;; on-key : KeyEvent World -> World
(define (on-key k w) 10)

(big-bang 10
          [to-draw draw]
          [on-tick tick])
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
#lang class/1
(require 2htdp/image class/universe)

;; A World (new world% Number)
(define-class world%
  (fields n)
  ;; on-tick : -> World
  (define (on-tick)
    (new world% (add1 (this . n))))
  ;; to-draw : -> Image
  (define (on-tick) 
    (circle (this . n) "solid" "red"))
  ;; on-key : KeyEvent -> World
  (define (on-key k) (new world% 10)))
  
(big-bang (new world% 10))
\end{verbatim}
\end{minipage}
\caption{World programs}
\label{fig:world}
\end{figure}




[First semester vs second semester example programs.]

\section{From principles to industrial languages}
\label{sec:industrial}

Could work with any fashion, and should really lead into many
fashionable languages.  The purpose of showing many is to demonstrate
that the same principles apply in each setting.  Each language can also
expose students to various mechanisms.

\subsection{Java}

\begin{itemize}
\item Types
\item Compiler
\item ``Industrial'' features (collections library, ...)
\end{itemize}



\section{Our course}
\label{sec:our-course}

\subsection{Representation-independence and interface-oriented programming}

\subsection{Distributed, Interactive Programs}

\subsection{Unifying functions and objects}


\section{Related work}
\label{sec:related-work}

\cite{dvanhorn:Gray2003ProfessorJ}

\cite{dvanhorn:Allen2002DrJava, dvanhorn:Hsia2005Taming}

\cite{dvanhorn:Kolling2003}

\cite{dvanhorn:Bruce2001Library}

\cite{dvanhorn:Alphonce2003Using}

\cite{dvanhorn:Chakravarty2004Risks}

\cite{dvanhorn:Ragde2008Chilling}

\cite{dvanhorn:Bloch2000Scheme}

The noble goals of ProfJ:

\begin{itemize}
\item language levels
\item continuity in IDE from first semester
\end{itemize}

Many of the shortcomings of HtDC and ProfJ are ``day 1'' problems.
The transition is too abrupt and too large.

The failures of  ProfJ:

\begin{itemize}
\item dead.
\item changes languages from first semester rather than adding new
  concept (causes students confusing deep issue (O.O. design) and
  shallow ones (Java-like syntax) and orthogonal issues (static type
  discipline).  (This also ultimately lead to the tool being abandoned
  as it was too difficult to maintain.)

\item commits to a particular fashion rather than enabling any.

\item abandons the first semester approach and replaces it with a
  (completely) object-oriented approach on day one.  There are
  analogies between functional and object concepts (``a method is like
  a function''), but the two never co-exist in a program.

\item Java, even pared down pedagogical Java, is syntactically heavy; discourages
  interactive programming

\end{itemize}

The changes that occur on Day 1 of HtDC w/ ProfJ:

\begin{itemize}
\item Radically different syntax
\item Types
\item Total commitment to objects
\item Subtly different base values
\end{itemize}

The changes that occur on Day 1 of HtDC w/o ProfJ:

\begin{itemize}
\item Different IDE
\item Compilation
\item Loss of interactivity
\end{itemize}

\section{Experience and outlook}
\label{sec:conclusion}

Perspective into the upper-class curriculum:

\begin{itemize}
\item types, contract, invariants : formal methods, program verification,
  
\item representation independence : component-based software engineering,
  data-structures, algorithms

\item interfaces, interactions, distribution : operating systems, networking
\end{itemize}


Other steps:
\begin{itemize}
\item types in class language
\item pedagogical Java environment
\item ugly syntax for class language
\item world in Java
\end{itemize}

\cite{dvanhorn:sicp}

\cite{local:htdc}

\subsection*{Acknowledgements}

Matthias Felleisen's approach to pedagogy and passion for
undergraduate teaching has inspired this work from the beginning.
CCIS Dean Larry Finkelstein entrusted two postdocs with the redesign
of a key undergraduate course, which made this experiment possible.
Our teaching assistants, Dan Brown, Asumu Takikawa, and Nicholas
Labich, as well as the tutors and graders, contributed enormously to
the success of our courses. Finally, and most importantly, our
students at Northeastern for the last three years have put up with a
curriculum in progress, and the opportunity to teach them has been
truly rewarding.

% \nocite{*}
\bibliographystyle{eptcs}
\bibliography{dvh-bibliography,local}
\end{document}
