% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz} 
\usepackage[]{xcolor}
\usepackage{qtree} 
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{alltt}
\usepackage{ct} % tight CM font for \tt
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{\color{red}}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\centerline{\Large CSU2510H Exam 2 \ifrubric (SOLUTION) \fi-- Spring 2012}

\vspace{0.5cm}

\ifrubric\relax\else
\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}
\fi

\noindent\begin{minipage}{8cm}\sloppy
\begin{itemize}
\item You may use the usual primitives and expression forms of any of
  the \code{class} languages; for everything else, define it.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} as
  shorthand for writing both {\tt check-expect} and {\tt
    Tester.checkExpect}.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item We expect data \emph{and} interface definitions.

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

% \item The extra credit problem is \emph{all or nothing};  no partial
%   credit will be awarded.

\item Unless specifically requested, templates and super classes are
  \emph{not} required.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can  think
about the harder problems in the background while you knock off the easy ones.
\end{itemize}

\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & 15\\ \hline
2 & & 22\\ \hline
3 & & ??\\ \hline
4 & & ??\\ \hline
5 & & ??\\ \hline
%% Extra & & 5 \\ \hline
{\bf Total} & & ?? \\ \hline
%{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}\pts{15} % same as on the previous exam :)


  While trying to manage the grade database, Asumu hit upon a new idea
  for a data structure: the 2/3-tree.  A 2/3-tree is either a leaf
  (which holds a {\tt String} value), a 2-node, or a 3-node.  A 2-node
  has two children, and a 3-node has three children.  The twist is
  that a 2-node can't have any 2-nodes as children, and a 3-node can't
  have any 3-nodes as children.



Here's an example of a 2/3-tree:

\vspace*{8mm}
\bigskip

\Tree [. {\tt "Bread"} {\tt "Hat"} [. [. {\tt "Zebra"} {\tt "Dog"} {\tt
  "Cat"} ] {\tt "Rhinocerous"}  ] !{\qbalance} ]

\bigskip
\bigskip

\begin{enumerate}

\item Design data, class, and interface definitions, in Java, to
  represent 2/3-trees.  Construct the above example using your
  definitions.

\item Design the {\tt height} method, which computes the height of the
  tree (i.e., the maximum distance from the root to a leaf).  The
  example tree has a height of 4.

\end{enumerate}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}
//> 4pts for interfaces
interface Tree {
  //> 1pt for purpose
  // count the height of this tree
  Integer height();
}

interface TwoTree extends Tree {}
interface ThreeTree extends Tree {}
\end{verbatim}
\newpage
\begin{verbatim}
//> 4pts for class definitions
//> 3pts for method definitions
class Leaf implements TwoTree, ThreeTree {
  String val;

  Integer height() { return 1; }
}

class TwoNode implements TwoTree {
  ThreeTree left;
  ThreeTree right;

  Integer height() { return max(this.left.height(), this.right.height()); }
}

class ThreeNode implements ThreeTree {
  TwoTree left;
  TwoTree mid;
  TwoTree right;

  Integer height() { return max(this.left.height(),
                                this.mid.height(),
                                this.right.height()); }
}

Tree r = new Leaf("Rhinocerous");
Tree h = new Leaf("Hat");
Tree b = new Leaf("Bread");
Tree t1 = new ThreeNode(new Leaf("Zebra"),new Leaf("Dog"),new Leaf("Cat"));
Tree t2 = new TwoNode(t1,r);
Tree t3 = new ThreeNode(b,h,t2);

//> 3pts for tests
t3.height -> 4
r.height -> 1
t2.height -> 3
\end{verbatim}
\end{solution}
\end{problem}
%\ifrubric\bigskip\else
\newpage
%\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{22}

Design a \verb|TreeVisitor| interface for 2/3-trees, and implement the
\verb|visit| method in all of your classes from the previous problem.
Make sure you design the interfaces and methods so that a visitor can
return any type of data.

\begin{solution}
\begin{verbatim}
//> 2pts parameterization
//> 2pts methods
interface TreeVisitor<T> {
  T visitLeaf(String s);
  T visitTwoNode(ThreeTree l, ThreeTree r);
  T visitThreeNode(TwoTree l, TwoTree r);
}

//> 2pts overall for getting types right
//> 3pts overall for getting impls right

// in Leaf:
<T> T visit(TreeVisitor<T> v) { 
  return v.visitLeaf(this.val);
}

// in TwoNode:
<T> T visit(TreeVisitor<T> v) { 
  return v.visitTwoNode(this.left, this.right);
}

// in ThreeNode:
<T> T visit(TreeVisitor<T> v) { 
  return v.visitThreeNode(this.left, this.mid, this.right);
}
// no tests required!
\end{verbatim}
\end{solution}

\newpage

\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
\fi


Design the \verb|CountVisitor| class, which counts the number of
leaves in a 2/3-tree (there are 6 in the given example.)

\begin{solution}
\begin{verbatim}
//> 2pts class def
//> 2pts implementations
class CountVisitor implements TreeVisitor<Integer> {
  Integer visitLeaf(String s) { return 1; }
  Integer visitTwoNode(Tree l, Tree r) { return l.visit(this) + r.visit(this); }
  Integer visitThreeNode(Tree l, Tree m, Tree r) { 
     return l.visit(this) + r.visit(this) + m.visit(this);
  }
}
//> 2pts tests
r.visit(new CountVisitor()) -> 1
t2.visit(new CountVisitor()) -> 4
t3.visit(new CountVisitor()) -> 6
\end{verbatim}
\end{solution}

\newpage

Design the \verb|LongestVisitor| class, which produces the longest
\verb|String| in a 2/3-tree.  The longest string in the example is
\verb|"Rhinocerous"|.  

\begin{solution}
\begin{verbatim}
// 2pts class def
// 3pts methods
class LongestVisitor implements TreeVisitor<String> {
  String visitLeaf(String s) { return s; }
  String visitTwoNode(Tree l, Tree r) { 
     String s1 = l.visit(this);
     String s2 = r.visit(this);
     return (s1.length() > s2.length())?s1:s2;
  }
  String visitThreeNode(Tree l, Tree m, Tree r) { 
     String s1 = l.visit(this);
     String s2 = r.visit(this);
     String s3 = m.visit(this);
     if (s1.length() > s2.length() && s1.length() > s3.length())
       return s1;
     else if (s2.length() > s3.length())
       return s2;
     else
       returns s3;
  }
}
//> 2pts tests
h.visit(new LongestVisitor()) -> "Hat"
t2.visit(new LongestVisitor()) -> "Rhinocerous"
t3.visit(new LongestVisitor()) -> "Rhinocerous"
\end{verbatim}
\end{solution}

\newpage

\end{problem}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{??}

In mathematics, an {\bf unordered} pair is a pair of values in which
the order of the elements does not matter.  So for example, if
$\{3,4\}$ is an unordered pair, then it should be considered ``the
same'' as the unordered pair $\{4,3\}$.  Here is an implementation of
{\tt UnPair}, which represents unordered pairs.  Notice that both {\tt
  equals} and {\tt hashCode} have been overridden.

\begin{verbatim}
class UnPair<X> {
  X left;
  X right;
  UnPair(X left, X right) {
    this.left = left;
    this.right = right;
  }

  // Compute the hash of this unordered pair.
  public int hashCode() {
    return left.hashCode();
  }

  // Is this unordered pair the same as the given unordered pair?
  public boolean same(UnPair<X> p) { ... }

  // Is this unordered pair the same as the given object?
  public boolean equals(Object that) {
    return (that instanceof UnPair)
        && this.same((UnPair<X>)that);
  }
}
\end{verbatim}

\newpage
\noindent
Part (A): Implement the omitted {\tt same} method that compares this
unordered pair to a given unordered pair.  This method should work
regardless of the order of the pair, so for example {\tt new
  UnPair<Integer>(3,4)} is the same (according to {\tt same}) as {\tt
  new UnPair<Integer>(4,3)}.

\newpage
\noindent
Part (B): Assuming {\tt same} and {\tt equals} work as expected, is
the given {\tt hashCode} method valid?  That is, does it satisfy or
violate the law of {\tt hashCode}?  If it is valid, give an argument
for \emph{why}.  If it is not, give a counter-example to the law of
{\tt hashCode}.
\end{problem}
\newpage

\begin{problem} \pts{??}

Lists are nice, but sometimes it would be better to have a list
without an end.  For example, we might want to model the days of the
week as a list that wraps around at the end so that Monday follows
Sunday.  To do so, we need lists that are \emph{circular}, and in
order to make circular lists, we need to use mutation.  Here's an idea
for a list method that makes is possible to create cyclic lists:

\begin{verbatim}
interface List<X> {
   // EFFECT: set the rest of the last cons in this list
   // to the given list.
   void setTail(List<X> ls);
}
\end{verbatim}

\noindent
It works as follows:

\begin{verbatim}
List<Integer> waltz =
  new Cons<Integer>(1,
    new Cons<Integer>(2,
      new Cons<Integer>(3,
        new MT<Integer>())));

\end{verbatim}
At this point, {\tt waltz} is just a list of three elements {\tt 1, 2,
  3}.  To make the list circular we can call {\tt setTail} giving {\tt
  waltz} as the new tail:

\begin{verbatim}
waltz.setTail(waltz);
\end{verbatim}

\noindent
Now {\tt waltz} is a list of elements: {\tt 1, 2, 3, 1, 2, 3, 1, 2, 3,
  \dots}, and so on, \emph{ad infinitum}.

Of course, it's also possible to use {\tt setTail} to update a list in
a non-circular way.  Imagine instead we had just done:

\begin{verbatim}
waltz.setTail(new Cons<Integer>(4, new MT<Integer>()));
\end{verbatim}

\noindent
In this case, {\tt waltz} is now just {\tt 1, 2, 3, 4}.

\newpage
Design an implementation of {\tt setTail} that works as described.
Revise the {\tt List<X>} interface with any methods you need to add to
make {\tt setTail} work.  (You'll notice that the effect statement for
{\tt setTail} implies that this list cannot be empty; if you try to
{\tt setTail} on an empty list, you may raise an exception.)

\end{problem}

\end{document}


