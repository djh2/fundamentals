% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz} 
\usepackage[]{xcolor}
\usepackage{qtree} 
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{alltt}
\usepackage{ct} % tight CM font for \tt
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{\color{red}}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\centerline{\Large CSU2510H Exam 2 \ifrubric (SOLUTION) \fi-- Spring 2012}

\vspace{0.5cm}

\ifrubric\relax\else
\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}
\fi

\noindent\begin{minipage}{8cm}\sloppy
\begin{itemize}
\item You may use the usual primitives and expression forms of any of
  the \code{class} languages; for everything else, define it.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} as
  shorthand for writing both {\tt check-expect} and {\tt
    Tester.checkExpect}.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item We expect data \emph{and} interface definitions.

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

% \item The extra credit problem is \emph{all or nothing};  no partial
%   credit will be awarded.

\item Unless specifically requested, templates and super classes are
  \emph{not} required.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can  think
about the harder problems in the background while you knock off the easy ones.
\end{itemize}

\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & 15\\ \hline
2 & & 22\\ \hline
3 & & ??\\ \hline
4 & & ??\\ \hline
5 & & ??\\ \hline
%% Extra & & 5 \\ \hline
{\bf Total} & & ?? \\ \hline
%{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}\pts{15} % same as on the previous exam :)


  While trying to manage the grade database, Asumu hit upon a new idea
  for a data structure: the 2/3-tree.  A 2/3-tree is either a leaf
  (which holds a {\tt String} value), a 2-node, or a 3-node.  A 2-node
  has two children, and a 3-node has three children.  The twist is
  that a 2-node can't have any 2-nodes as children, and a 3-node can't
  have any 3-nodes as children.



Here's an example of a 2/3-tree:

\vspace*{8mm}
\bigskip

\Tree [. {\tt "Bread"} {\tt "Hat"} [. [. {\tt "Zebra"} {\tt "Dog"} {\tt
  "Cat"} ] {\tt "Rhinocerous"}  ] !{\qbalance} ]

\bigskip
\bigskip

\begin{enumerate}

\item Design data, class, and interface definitions, in Java, to
  represent 2/3-trees.  Construct the above example using your
  definitions.

\item Design the {\tt height} method, which computes the height of the
  tree (i.e., the maximum distance from the root to a leaf).  The
  example tree has a height of 4.

\end{enumerate}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}
//> 4pts for interfaces
interface Tree {
  //> 1pt for purpose
  // count the height of this tree
  Integer height();
}

interface TwoTree extends Tree {}
interface ThreeTree extends Tree {}
\end{verbatim}
\newpage
\begin{verbatim}
//> 4pts for class definitions
//> 3pts for method definitions
class Leaf implements TwoTree, ThreeTree {
  String val;

  Integer height() { return 1; }
}

class TwoNode implements TwoTree {
  ThreeTree left;
  ThreeTree right;

  Integer height() { return max(this.left.height(), this.right.height()); }
}

class ThreeNode implements ThreeTree {
  TwoTree left;
  TwoTree mid;
  TwoTree right;

  Integer height() { return max(this.left.height(),
                                this.mid.height(),
                                this.right.height()); }
}

Tree r = new Leaf("Rhinocerous");
Tree h = new Leaf("Hat");
Tree b = new Leaf("Bread");
Tree t1 = new ThreeNode(new Leaf("Zebra"),new Leaf("Dog"),new Leaf("Cat"));
Tree t2 = new TwoNode(t1,r);
Tree t3 = new ThreeNode(b,h,t2);

//> 3pts for tests
t3.height -> 4
r.height -> 1
t2.height -> 3
\end{verbatim}
\end{solution}
\end{problem}
%\ifrubric\bigskip\else
\newpage
%\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{22}

Design a \verb|TreeVisitor| interface for 2/3-trees, and implement the
\verb|visit| method in all of your classes from the previous problem.
Make sure you design the interfaces and methods so that a visitor can
return any type of data.

\begin{solution}
\begin{verbatim}
//> 2pts parameterization
//> 2pts methods
interface TreeVisitor<T> {
  T visitLeaf(String s);
  T visitTwoNode(ThreeTree l, ThreeTree r);
  T visitThreeNode(TwoTree l, TwoTree r);
}

//> 2pts overall for getting types right
//> 3pts overall for getting impls right

// in Leaf:
<T> T visit(TreeVisitor<T> v) { 
  return v.visitLeaf(this.val);
}

// in TwoNode:
<T> T visit(TreeVisitor<T> v) { 
  return v.visitTwoNode(this.left, this.right);
}

// in ThreeNode:
<T> T visit(TreeVisitor<T> v) { 
  return v.visitThreeNode(this.left, this.mid, this.right);
}
// no tests required!
\end{verbatim}
\end{solution}

\newpage

\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
\fi


Design the \verb|CountVisitor| class, which counts the number of
leaves in a 2/3-tree (there are 6 in the given example.)

\begin{solution}
\begin{verbatim}
//> 2pts class def
//> 2pts implementations
class CountVisitor implements TreeVisitor<Integer> {
  Integer visitLeaf(String s) { return 1; }
  Integer visitTwoNode(Tree l, Tree r) { return l.visit(this) + r.visit(this); }
  Integer visitThreeNode(Tree l, Tree m, Tree r) { 
     return l.visit(this) + r.visit(this) + m.visit(this);
  }
}
//> 2pts tests
r.visit(new CountVisitor()) -> 1
t2.visit(new CountVisitor()) -> 4
t3.visit(new CountVisitor()) -> 6
\end{verbatim}
\end{solution}

\newpage

Design the \verb|LongestVisitor| class, which produces the longest
\verb|String| in a 2/3-tree.  The longest string in the example is
\verb|"Rhinocerous"|.  

\begin{solution}
\begin{verbatim}
// 2pts class def
// 3pts methods
class LongestVisitor implements TreeVisitor<String> {
  String visitLeaf(String s) { return s; }
  String visitTwoNode(Tree l, Tree r) { 
     String s1 = l.visit(this);
     String s2 = r.visit(this);
     return (s1.length() > s2.length())?s1:s2;
  }
  String visitThreeNode(Tree l, Tree m, Tree r) { 
     String s1 = l.visit(this);
     String s2 = r.visit(this);
     String s3 = m.visit(this);
     if (s1.length() > s2.length() && s1.length() > s3.length())
       return s1;
     else if (s2.length() > s3.length())
       return s2;
     else
       returns s3;
  }
}
//> 2pts tests
h.visit(new LongestVisitor()) -> "Hat"
t2.visit(new LongestVisitor()) -> "Rhinocerous"
t3.visit(new LongestVisitor()) -> "Rhinocerous"
\end{verbatim}
\end{solution}

\newpage

\end{problem}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{15}

In order to manage class scheduling, the College decided that they
needed to create a new implementation of the \verb|Set| data
structure.  They went with the lowest bidder, which
turned out to be a bunch of BU students.  Now, having paid for this
code, the College needs to test it, and they turn to you.  

Unfortunately, the code the BU students produced is so convoluted that
it doesn't bear looking at.  All you have to go on is that the
\verb|Set| data structure obeys the following interface:

\begin{verbatim}
;; A Set implements:
;; - insert : String -> Set
;;   adds given string to this set, if it isn't already there
;;   (otherwise produces this set)
;; - remove : String -> Set
;;   removes given string from this set, if it's already there
;;   (otherwise produces this set)
;; - size : -> Number
;;   count the elements of this set
;; - has? : String -> Boolean
;;   is the given String in this set?

;; empty-set is a Set value containing no elements
\end{verbatim}
\noindent
\verb|Set|s should satisfy the following property, called the
``insert-size'' property, for any element and
set:

\begin{quote}
If we insert any element into any set, then the resulting set is the
same size as the original set \emph{if} the element was already in the
set, and the resulting set is one larger than the original set
if the element was \emph{not} already in the set.
\end{quote}

\begin{enumerate}
\item Codify the ``insert-size'' property as a predicate.  Write a
  test case that should pass (if the sets work right) using the
  predicate you have defined.
\end{enumerate}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\fi

\newpage
\noindent
The College wants to be really sure that their sets are correct, and
they've come up with another property that they think is true, called
the ``insert-remove'' property:

\begin{quote}
If we insert element any element $a$ into any set, and then remove any
element $b$ from the resulting set, the result has the same size as if
we do the two operations in the reverse order, i.e., remove $b$, then
insert $a$.
\end{quote}

\noindent
The College is considering adding this to the test suite as well.

\begin{enumerate}
\setcounter{enumi}{1}

\item Codify this property as a predicate, and write a test case that
  should pass using the predicate.

\item Is the ``insert-remove'' property true for all sets?  If so,
  give an explanation.  If not, write a counter-example (i.e., a
  failing test case) using your predicate.

\end{enumerate}

\begin{solution}
\begin{alltt}
\rubricpts{1 pt -- contract & purpose}
;; check-insert-size : Set String -> Boolean
;; check the "insert-size" property on s and i.
\rubricpts{4 pts -- code}
(define (check-insert-size s i)
  (= (s . insert i . size)
     (cond [(s . has? i) (add1 (s . size))]
           [else               (s . size)])))

\rubricpts{2 pts -- test case}
(check-expect (check-insert-size empty-set "hi") true)

\rubricpts{1 pt -- contract & purpose}
;; check-remove-insert : Set String -> Boolean
;; check the "remove-insert" property on s, a, and b.
\rubricpts{3 pts -- code}
(define (check-remove-insert s a b)
  (= (s . insert a . remove b . size)
     (s . remove b . insert a . size))

\rubricpts{1 pt -- successful test}
(check-expect (check-remove-insert empty-set "yes" "no") true)

;; Property does not hold.
;; Counter-example (failing test):
\rubricpts{3 pts -- failing test}
(check-expect (check-remove-insert empty-set "yes" "yes") true)
\end{alltt}
\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
\fi
\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{15}

Here are data and class definitions for representing the files and
directories of a computer:

\begin{verbatim}
;; An Elem is one of
;; - (new file% String Number)
;; - (new dir% String LoElem)
(define-class file% (fields name size))
(define-class dir% (fields name elems))

;; A LoElem is one of
;; - (new mt%)
;; - (new cons% Elem LoElem)
(define-class mt%)
(define-class cons% (fields first rest))    
\end{verbatim}


\noindent
Here is an example of a directory tree and its representation as an
\verb|Elem|:
\begin{verbatim}
#|
 User
   +-- A
   |   +-- a.txt
   |   +-- B
   |       +-- b.rkt
   +-- C
       +-- c.c
|#

(define mt (new mt%))
(define a (new file% "a.txt" 5))
(define b (new file% "b.rkt" 10))
(define c (new file% "c.c" 1000))

(define C/ (new dir% "C" (new cons% c mt)))
(define B/ (new dir% "B" (new cons% b mt)))
(define A/ (new dir% "A" (new cons% a (new cons% B/ mt))))
(define User/ (new dir% "/" (new cons% A/ (new cons% C/ mt))))
\end{verbatim}

\newpage
\noindent
Your job is to implement one of the main tasks of the common Unix
utility \verb|find|, which gives a list of all the files within an
element.  To do so, add a \verb|list-files| method of \verb|Elem|
which produces a list of files.  So for example, we expect:
\begin{verbatim}
(check-expect (User/ . list-files) 
              (new cons% a (new cons% b (new cons% c mt))))
\end{verbatim}
\emph{Hint}: it may come in handy to be able to concatenate two
\verb|LoElem| together.

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\fi

\begin{solution}
\begin{alltt}
\rubricpts{1pts -- interfaces, contracts, purpose}
;; An Elem implements
;; - list-files : -> LoElem
;;   List all files within this element.

\rubricpts{2pts -- interfaces, contracts, purpose}
;; A LoElem implements
;; - list-files : -> LoElem
;;   List all files within this list of elements.
;; - append : LoElem -> LoElem
;;   Append this list of elements to given list.

\rubricpts{1pt -- code}
;; in dir%
(define (list-files)
  (this . elems . list-files))

\rubricpts{1pt -- code}
;; in file%
(define (list-files)
  (new cons% this (new mt%)))

\rubricpts{2pt -- code}
;; in mt%
(define (append loe) loe)
(define (list-files) this)

\rubricpts{4pt -- code}
;; in cons%
(define (append loe)
  (new cons% (this . first) (this . rest . append loe)))
(define (list-files)
  (this . first . list-files . append (this . rest . list-files)))

\rubricpts{1pt -- sanity}

\rubricpts{3pts -- tests}
;; tests
(check-expect (mt . append (new cons% a mt)) (new cons% a mt))
(check-expect ((new cons% a mt) . append (new cons% b mt))
              (new cons% a (new cons% b mt)))

(check-expect (mt . list-files) mt)
(check-expect ((new cons% a (new cons% b mt)) . list-files)
              (new cons% a (new cons% b mt)))

(check-expect (a . list-files) (new cons% a mt))
\end{alltt}
\end{solution}

\end{problem}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{18}
Last night, Asumu was up late improving the {\tt class} languages.
Unfortunately, he was too tired to test his work, and his last commit
broke the numeric system.
%
This puts us in the dire position of no longer being able to calculate
the factorial of large numbers, and we turn to you for help.

This is the definition of a class of functional objects
with a {\tt fact} method:

\begin{verbatim}
;; A Fact is (new fact%) and implements 
;; - fact : Natural -> Natural
;;   Compute n!.
(define-class fact%
  (define (fact n)
    (cond [(zero? n) 1]
          [else (* n (this . fact (sub1 n)))])))

(check-expect ((new fact%) . fact 0) 1)
(check-expect ((new fact%) . fact 5) 120)
\end{verbatim}

Since we can no longer rely on built in numbers to represent
\verb|Natural|s, we will represent \verb|Natural|s with objects and
then rewrite the \verb|fact| method to operate over this new kind of
data.

Here is the \verb|Natural| interface:

\begin{verbatim}
;; A Natural implements:
;; - zero? : -> Boolean
;;   is this Natural the zero value?
;; - sub1 : -> Natural
;;   produce a natural one less than this natural 
;;   (or zero if this natural is zero)
;; - times : Natural -> Natural
;;   multiply this natural by the given natural
\end{verbatim}

\newpage
Write a new definition of the \verb|fact| method using the
\verb|Natural| interface definition given above, and \emph{not} using
the built-in numbers of the class system or DrRacket.  You can assume
there is a defined constant \verb|one|, which is a \verb|Natural|
object representing $1$.

\begin{verbatim}
(check-expect ((new fact%) . fact one) one)
(check-expect ((new fact%) . fact (one . sub1)) one)
\end{verbatim}


\begin{solution}
\begin{alltt}
\rubricpts{2 pts}
(define-class fact%
  (define (fact n)
    (cond [(n . zero?) one]
          [else (n . times (this . fact (n . sub1)))])))

\end{alltt}
\end{solution}

\newpage

Now, design data and class defintions that implement \verb|Natural|, and
supports the methods \verb|zero?|, \verb|sub1|, and \verb|times|.
Define the constant \verb|one|.  (\emph{Hint}: remember that the
natural numbers can be seen as a recursive union; a natural number is
either zero, or one more than a natural number.)

It will be helpful to define the helper methods \verb|add1| and
\verb|plus|.  Also, remember that $n + m = (n-1) + m + 1$ and that $n
\cdot m = (n-1) \cdot m + m$.  Don't overlook the slightly weird
specification for \verb|sub1|: $0-1 = 0$; this weirdness is common
amongst mathematicians when working with natural numbers.

\ifrubric
\else
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi
\end{problem}

\begin{solution}
\begin{alltt}
\rubricpts{2 pts -- data defintion}
;; A Natural is one of
;; - (new zero%)
;; - (new add1% Natural)
(define-class zero%
  \rubricpts{4 pts -- methods in zero%}
  (define (sub1) this)
  (define (zero?) true)
  (define (add1) (new add1% this))
  (define (plus n) n)
  (define (times n) this))

(define-class add1%
  (fields sub1)
  \rubricpts{7 pts -- methods in add1%}
  (define (zero?) false)
  (define (add1) (new add1% this))
  (define (plus n) (this . sub1 . plus n . add1))
  (define (times n) (this . sub1 . times n . plus n)))

(define zero (new zero%))
\rubricpts{1 pt -- define one}
(define one (new add1% (new zero%)))

\rubricpts{3 pts -- tests}
(check-expect (one . zero?) false)
(check-expect (one . sub1) zero)
(check-expect ((new add1% one) . sub1) one)
(check-expect (zero . zero?) true)
(check-expect (zero . sub1) zero)
\end{alltt}
\newpage
\end{solution}

\begin{problem}\pts{5}

\textbf{Extra Credit}
\\
\noindent
After Van Horn discovered the problems with numbers, he attempted to
fix them.  Unfortunately, not only did he not fix them, he broke
booleans as well.  Fortunately, we have an idea about how you can
help, expressed in the following interface definitions.  

\begin{verbatim}
;; A Bool implements:
;; - branch : [Action X] [Action X] -> X
;;   run the first action if this bool is true, 
;;   otherwise run the second action

;; An [Action X] implements:
;; - run : -> X
;; run this action


\end{verbatim}

Following these interface definitions, design data and class
defintions for implementations of the \verb|Bool| interface, and
reimplement the \verb|fact| method to use them.
You will need to provide new defintions for \verb|true| and
\verb|false|, since they were broken by this catastrophe as well.

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\fi


\begin{solution}
\begin{alltt}
\rubricpts{5 pts -- get it right}
(define-class fact%
  (define (fact n)
    (n . zero? . branch (new const% one) (new recur% n))))

(define-class const%
  (fields run))

(define-class recur%
  (fields n)
  (define (run) 
    ((new fact%) . fact (this . n . sub1) . times (this . n))))

(define-class t%
  (define (branch t e) (t . run)))
(define-class f%
  (define (branch t e) (e . run)))

(define true (new t%)) 
(define false (new f%))

(check-expect ((new fact%) . fact zero) one)                  ; 0! = 1
(check-expect ((new fact%) . fact one) one)                   ; 1! = 1
(check-expect ((new fact%) . fact (one . add1)) (one . add1)) ; 2! = 2
(check-expect ((new fact%) . fact (one . add1 . add1))        ; 3! = 6
              (one . add1 . add1 . add1 . add1 . add1))
\end{alltt}
\end{solution}
\end{problem}
\end{document}


